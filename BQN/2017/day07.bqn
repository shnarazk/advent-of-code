Solve â‡ {envâ€¿part ğ•Š data :
  utilâ€¿âŸ¨hashmapâŸ© â† â€¢ImportÂ¨"/util.bqn"â€¿"/hashmap.bqn"âˆ¾ËœÂ¨<"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  data (" ->,"âŠ¸util.Split)Â¨ â†©
  parent â† HashmapËœâŸ¨âŸ©
  {âŸ¨node,weightâŸ©â€¿nodes â† 2(â†‘â‹ˆâ†“)ğ•© â‹„ parent.SetâŸœnodeÂ¨nodes}Â¨data
  root â† parent.Getâ€¢_while_(parent.Has)Â¯1âŠ‘parent.Valuesâ¼@
  {
    1=part ? root ;
    subnodes â† HashmapËœâŸ¨âŸ©
    weight â† HashmapËœâŸ¨âŸ©
    treeweight â† HashmapËœâŸ¨âŸ©
    {âŸ¨node,wâŸ©â€¿nodes â† 2(â†‘â‹ˆâ†“)ğ•© â‹„ node weight.Set util.ParseInt w â‹„ node subnodes.Set nodes}Â¨data
    {ğ•© treeweight.Set w â† (weight.Get ğ•©)++Â´ğ•ŠÂ¨subnodes.Get ğ•© â‹„ w}root
    Check â† {
      uws â† â· ws â† treeweight.GetÂ¨ nodes â† subnodes.Get ğ•©
      {
        1â‰¥â‰ uws ? âˆ¾CheckÂ¨nodes ;
        "# wrong weight index" util.Debug target â† 1<+Â´(âŠ‘uws)=ws
        "# node index" util.Debug i â† (wsâŠ¸âŠ)âŒ¾â‹ˆtargetâŠ‘uws
        {âŸ¨âŸ©â‰¢r â† Check iâŠ‘nodes ? r ; âŸ¨(targetâ—¶âŸ¨-,âŠ¢âŸ©-Â´uws)+weight.Get iâŠ‘nodesâŸ©}
      }
    }
    âŠ‘Check root
  }
}
