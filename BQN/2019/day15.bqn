Solve â‡ {envâ€¿part ğ•Š data :
  utilâ€¿geoâ€¿âŸ¨hashmapâŸ© â† â€¢ImportÂ¨"/util.bqn"â€¿"/geometry.bqn"â€¿"/hashmap.bqn"âˆ¾ËœÂ¨<"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  data util.ParseIntsâˆ˜âŠ‘ â†©
  intcode â† â€¢Import "/2019/intcode.bqn"âˆ¾Ëœ"." env.VarâŒ¾â‹ˆ "AOC_BQN_DIR"
  droid â† intcode.Intcode data
  Turn â† {
    ğ•Š  ğ•© : âŸ¨Â¯1â€¿0,0â€¿1,1â€¿0,0â€¿Â¯1âŸ©{ğ•¨âŠ‘Ëœ4| 1+ğ•¨âŠ¸âŠâŒ¾â‹ˆğ•©}ğ•© ;
    ğ•Šâ¼ ğ•© : âŸ¨Â¯1â€¿0,0â€¿1,1â€¿0,0â€¿Â¯1âŸ©{ğ•¨âŠ‘Ëœ4|Â¯1+ğ•¨âŠ¸âŠâŒ¾â‹ˆğ•©}ğ•©
  }
  EncodeDir â† âŸ¨0â€¿0,Â¯1â€¿0,1â€¿0,0â€¿1,0â€¿Â¯1âŸ©âŠ¸âŠâŒ¾â‹ˆ
  Check â† {((droid.Inputâ‹ˆEncodeDir ğ•©).Run@).Output@}
  map â† 0â€¿0 Hashmapâ—‹â‹ˆ 1
  target â† âˆâ€¿âˆ
    pos â† 0â€¿0
    dir â† 0â€¿Â¯1
    {
      {
        0 : (dir+pos)map.Set âˆ â‹„ "# hit wall" util.Debug dir Turn â†© ;
        1 : "# move" util.Debug pos dirâŠ¸+ â†© â‹„ pos map.Set 1 â‹„ dir Turnâ¼ â†© ;
        2 : "# found" util.Debug pos dirâŠ¸+ â†© â‹„ pos map.Set 1 â‹„ target â†© pos
      }Â¨Check dir
      1+ğ•©
    }â€¢_while_{ğ•¤ â‹„ âˆâ€¿âˆâ‰¡target}0
    minâ€¿max â† (âŒŠÂ´â‹ˆâŒˆÂ´)map.Valuesâ¼@
    m â† âˆÂ¨â†•shape â† maxÂ¬min
    mask â† m{pâ€¿d ğ•Š ğ•© : dâŒ¾((p-min)âŠ¸âŠ‘)ğ•©}Â´map.Valuesâ¼Ëœ@
  {
    1=part ? (target-min)âŠ‘âŠ‘{xâ€¿pre : âŸ¨maskÃ—xâŒŠ1+âŒŠÂ´Â¨âˆ geo.Neighbor5 x,xâŸ©}â€¢_while_(â‰¢Â´)âŸ¨0âŒ¾((0â€¿0-min)âŠ¸âŠ‘)m,@âŸ© ;
    âŠ‘{stepâ€¿x : âŸ¨1+step,maskÃ—xâŒŠâŒŠÂ´Â¨âˆ geo.Neighbor5 xâŸ©}â€¢_while_(âˆ¨Â´Â·2âŠ¸=Â·â¥Š1âŠ¸âŠ‘)âŸ¨0,1âŒ¾((target-min)âŠ¸âŠ‘)1+maskâŸ©
  }
}
