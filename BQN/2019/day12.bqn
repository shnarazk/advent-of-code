Solve â‡ {envâ€¿part ğ•Š data :
  utilâ€¿âŸ¨hashmapâŸ© â† â€¢ImportÂ¨"/util.bqn"â€¿"/hashmap.bqn"âˆ¾ËœÂ¨<"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  {
    1=part ?
      +Â´{(+Â´|ğ•¨)Ã—(+Â´|ğ•©)}Â´Ë˜â‰>{positionâ€¿velocity :
        velocity ((<+Â´)Ë˜(Ã—-)ËœâŒœËœposition)âŠ¸+ â†©
        âŸ¨"# positions" util.Debug position+velocity,velocityâŸ©
      }âŸ1000 â‹ˆâŸœ(0Â¨Â¨)util.ParseIntsÂ¨data
      ;
    data util.ParseIntsÂ¨ â†©
    h â† hashmapËœâŸ¨âŸ©
    â€¢math.lcmÂ´Â¯1âŠ‘{stepâ€¿positionâ€¿velocityâ€¿cycle :
      velocity ((<+Â´)Ë˜(Ã—-)ËœâŒœËœposition)âŠ¸+ â†©
      position velocityâŠ¸+ â†©
      {ğ•Š i:
        mask â† (iâŒ½3â†‘1)
        key â† âŸ¨iâŸ©âˆ¾((âˆ¾maskâŠ¸/Â¨)Ë˜position)âˆ¾((âˆ¾maskâŠ¸/Â¨)Ë˜velocity)
        {h.Has key ? {(0=iâŠ‘cycle) ? cycle (step-h.Get key)âŒ¾(iâŠ¸âŠ‘) â†© ; @} ;
         key h.Set step}
      }Â¨â†•3
      util.Progress h.Count@
      âŸ¨1+step,position,velocity,cycleâŸ©
    }â€¢_while_(âˆ¨Â´0=Â¯1âŠ¸âŠ‘)âŸ¨0,data,0Â¨Â¨data,0â€¿0â€¿0âŸ©
  }
}
