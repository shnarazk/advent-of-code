Solve â‡ {envâ€¿part ğ•Š line :
  utilâ€¿âŸ¨hashmapâŸ© â† â€¢ImportÂ¨"/util.bqn"â€¿"/hashmap.bqn"âˆ¾ËœÂ¨<"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  data â† >{[âŸ¨1âŠ‘ğ•©,0,0,0âŸ©,âŸ¨2âŠ‘ğ•©,0,0,0âŸ©,âŸ¨3âŠ‘ğ•©,4âŠ‘ğ•©,0,0âŸ©,âŸ¨5âŠ‘ğ•©,0,6âŠ‘ğ•©,0âŸ©]}âˆ˜util.ParseIntsÂ¨line
  Examine â† {u ğ•Š n :
    roundâ€¿bestâ€¿bpâ€¿upto â† âŸ¨0,0,nâŠdata,-uâŸ©
    masksâ€¿limits â† âŸ¨0<Ë˜bp,0â€¿0â€¿0â€¿âˆâŒˆâŒˆÂ´Ë˜â‰bpâŸ©
    {ğ•Š prev :
      util.ProgressâŸ¨n,round,best,+Â´â‰ Â¨prev.Values@âŸ©
      round 1âŠ¸+ â†©
      (HashmapËœâŸ¨âŸ©){robotsâ€¿value ğ•Š hash :
        {
          upto< t â† (âŠ‘value)- w â† 1+âŒˆâŒˆÂ´(ğ•©âŠmasks)/robotsÃ·Ëœ(no â† ğ•©âŠbp)(0âŒˆ-) resources â† 1â†“value ?
          rbâ€¿v â† âŸ¨1âŠ¸+âŒ¾(ğ•©âŠ¸âŠ‘)robots,âŸ¨tâŸ©âˆ¾no-Ëœresources+wÃ—robotsâŸ©
          Â¬âˆ¨Â´(âˆ§Â´vâŠ¸â‰¤)Â¨vals â† âŸ¨âŸ© hash.Get rb ?
          rb hash.Set âŸ¨vâŸ©âˆ¾(Â¬Â·âˆ§Â´vâŠ¸â‰¥)Â¨âŠ¸/vals
          best ((4âŠ‘v)+(t-upto)Ã—3âŠ‘rb)âŠ¸âŒˆ â†©
          ; @
        }Â¨{robots<â—‹(ğ•©âŠ¸âŠ‘)limits}Â¨âŠ¸/â†•4
        hash
      }Â´âˆ¾{ğ•¨âŠ¸â‹ˆÂ¨ğ•©}Â´Â¨prev.Valuesâ¼Ëœ@
    }â€¢_while_{0<ğ•©.Count@}âŸ¨4â†‘1âŸ©HashmapâŸ¨âŸ¨5â†‘0âŸ©âŸ©
    best
  }
  {1=part ? +Â´24((1âŠ¸+)Ã—Examine)Â¨â†•â‰ data ; Ã—Â´32 ExamineÂ¨â†•3}
}
