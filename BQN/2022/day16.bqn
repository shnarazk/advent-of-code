Solve â‡ {envâ€¿part ğ•Š rawdata :
  lib â† "." env.VarâŒ¾â‹ˆ "BQN_LIB"
  âŸ¨color,DataFile,Debug,ParseInts,Swap,termâŸ© â† â€¢Import libâˆ¾"/util.bqn"
  âŸ¨_to_heapâŸ©â€¿âŸ¨hashmapâŸ© â† â€¢ImportÂ¨(<lib)âˆ¾Â¨"/heap.bqn"â€¿"/hashmap.bqn"
  data â† âˆ§(Swap ParseInts âˆ¾{((<1âŠ¸âŠ‘)âˆ¾9âŠ¸â†“)(','âŠ¸â‰ Â¨âŠ¸/)Â¨" "âŠ¸((âŠ¢-ËœÂ¬Ã—Â·+`Â»âŠ¸<)âˆ˜âˆŠËœâŠ”âŠ¢)ğ•©})Â¨rawdata
  nodes â† â·âŠ‘Â¨data
  ! 0=âŠ‘nodesâŠ<"AA"
  pairs â† (â‹ˆâ—‹(âŠ‘nodesâŠ’<))Â´Â¨âˆ¾(âŠ(âˆ¾â—‹<)Â¨(2âŠ¸â†“))Â¨data
  dist â† (âŒŠËâˆ˜+â‰1â€¿âˆ)âŸ(â‰ nodes)Ëœ {ğ•¨â‰¡ğ•© ? 0 ; âŠ‘pairsâˆŠËœâ‹ˆâŸ¨ğ•¨,ğ•©âŸ© ? 1 ; âˆ}âŒœËœâ†•â‰ nodes
  {
    1=part ?
      To_visit â† (>â—‹(Â¯1âŠ¸âŠ‘))_to_heap
      to_visit.PushâŸ¨(0âŠ¸=)Â¨â†•â‰ nodes,0,0,0âŸ©   # heap of âŸ¨bitmap,position,time,flowâŸ©
      visited â† âˆ˜â€¿2â¥ŠâŸ¨âŸ¨(0âŠ¸=)Â¨â†•â‰ nodes,0,0âŸ©,0âŸ© # map  of âŸ¨bitmap,position,timeâŸ©â†’flow
      Expand â† { limit ğ•Š âŸ¨states,pos,time,flowâŸ©:
        {ğ•Š âŸ¨p,costâŸ© :
          t â† 1+time+cost
          {(0=cost)âˆ¨(pâŠ‘states)âˆ¨(limitâ‰¤t)âˆ¨(0=1âŠ‘pâŠ‘data) ? @ ;
            âŸ¨f,sâŸ© â† âŸ¨flow+(limit-t)Ã—1âŠ‘pâŠ‘data,1Ë™âŒ¾(pâŠ¸âŠ‘)statesâŸ©
            key_index â† âŠ‘(âŠ‘Ë˜visited)âŠâŸ¨key â† âŸ¨s,p,tâŸ©âŸ©
            {key_index<â‰ visited ? @ ; visited (âˆ¾âŸœ(âˆ˜â€¿2â¥ŠâŸ¨key,0âŸ©)) â†©} # ensure the key exists
            {fâ‰¤âŒˆÂ´(({(tâ‰¥2âŠ‘ğ•©)âˆ§(keyâ‰¡â—‹(2â†‘âŠ‘)ğ•©)}âˆ˜âŠ‘)Â¨)âŠ¸/âŸœ((1âŠ¸âŠ‘)Â¨)â¥Š<Ë˜visited ? @ ;
              to_visit.PushâŸ¨s,p,t,fâŸ©
              visited fË™âŒ¾(key_indexâ€¿1âŠ¸âŠ‘) â†©
            }
          }
        }Â¨(â†•â‰ )âŠ¸(â‹ˆÂ¨) posâŠdist
      }
      Search â† {heap F lim : heap{state â† ğ•¨.Pop@ â‹„ x â† ğ•©âŒˆÂ¯1âŠ‘state â‹„ lim Expand state â‹„ x}â€¢_while_{Â¬ğ•¨.Empty@}0}
      to_visit Search 30
    ;
      limit â† 26
      Togo â† (>â—‹(Â¯1âŠ¸âŠ‘))_to_heap
      togo.PushâŸ¨(0âŠ¸=)Â¨â†•â‰ nodes,âŸ¨0,0âŸ©,âŸ¨0,0âŸ©,0âŸ©       # âŸ¨bitmap,âŸ¨position1,time1âŸ©,âŸ¨position2,time2âŸ©,flowâŸ©
      checked â† âŸ¨âŸ¨(0âŠ¸=)Â¨â†•â‰ nodes,âŸ¨0,0âŸ©,âŸ¨0,0âŸ©âŸ©âŸ© HashMap âŸ¨0âŸ©
      Expand2 â† { bestâ€¿limit ğ•Š âŸ¨states,âŸ¨p1,t1âŸ©,âŸ¨p2,t2âŸ©,flowâŸ© :
        {ğ•Š âŸ¨p,costâŸ© :
          t â† 1+t1+cost
          {(0=cost)âˆ¨(pâŠ‘states)âˆ¨(limitâ‰¤t)âˆ¨(0=1âŠ‘pâŠ‘data) ? @ ;
            âŸ¨f,sâŸ© â† âŸ¨flow+(limit-t)Ã—1âŠ‘pâŠ‘data,1Ë™âŒ¾(pâŠ¸âŠ‘)statesâŸ©
            âŸ¨a,bâŸ© â† {t<t2 ? âŸ¨âŸ¨p,tâŸ©,âŸ¨p2,t2âŸ©âŸ© ; âŸ¨âŸ¨p2,t2âŸ©,âŸ¨p,tâŸ©âŸ©}
            length â† (Â¯1+limit-1âŠ‘a)âŒŠâ‰ remains â† âˆ¨(Â¬Â¨s)/(1âŠ‘Â¨data) # A* calculation
            {best<f++Â´remainsÃ—Â¨â—‹(lengthâŠ¸â†‘)âŒ½â†•limit-t ? f>0 checked.Get key â† sâ€¿aâ€¿b ? togo.Push keyâˆ¾âŸ¨fâŸ© â‹„ key checked.Set f ; @}
          }
        }Â¨(â†•â‰ )âŠ¸(â‹ˆÂ¨) p1âŠdist
      }
      togo{ğ•¨ ğ•Š b :
        best â† ğ•©âŒˆ3âŠ‘state â† ğ•¨.Pop@
        bestâ€¿limit Expand2 state
        best
      }â€¢_while_{Â¬ğ•¨.Empty@}0
  }
}
