Solve â‡ {envâ€¿part ğ•Š data :
  util â† â€¢Import"/util.bqn"âˆ¾Ëœ"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  Parse â† {
    digits â† âŸ¨âŸ©
    levels â† âŸ¨âŸ©
    0{
       '[' ğ•Š lv : 1+|lv ;
       ',' ğ•Š lv : -lv ;
       ']' ğ•Š lv : Â¯1+|lv ;
       ğ•¨ ğ•Š lv : ('0'â‰¤ğ•¨)âˆ§'9'â‰¥ğ•¨ ?
         digits âˆ¾âŸœ(util.ParseIntâ‹ˆğ•¨) â†©
         levels âˆ¾âŸœlv â†©
         lv ;
        !0
    }Â´âŒ½ğ•©
    digitsâ‹ˆlevels
  }
  Add â† {wdâ€¿wl ğ•Š xdâ€¿xl : âŸ¨wdâˆ¾xd,(Ã—Ã—1+|)Â¨wlâˆ¾xlâŸ©}
  Explode â† {ğ•Š dâ€¿l :
    âˆ¨Â´ables â† ((=Â´âˆ§(âˆ§Â´4âŠ¸â‰¤))1â€¿Â¯1âŠ¸Ã—)Ë˜2â†•l ?
      "Explode" util.Debug ables
      target â† ablesâŠ¸âŠâŒ¾â‹ˆ1
      "target" util.Debug target
      {0<target ? d (âŠ¢+targetâŠ‘d)âŒ¾((target-1)âŠ¸âŠ‘) â†© ; @}
      {(â‰ l)>2+target ? d (âŠ¢+(target+1)âŠ‘d)âŒ¾((target+2)âŠ¸âŠ‘) â†© ; @}
      # substitude the pair
      d
      ;
    ğ•©
  }
  Split â† {ğ•Š xdâ€¿xl : ğ•©}
  Combine â† {
    z â† ğ•¨ Add ğ•©
    # Explode and Split
    z
  }
  {
    1=part ?
    l â† ParseÂ¨data
    f â† âŠ‘l
    Explode "try explode" util.Debug f
    ;
      0
  }
}
