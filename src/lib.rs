use std::{fmt::Debug, fs::File, io::prelude::*};
pub mod template;
pub mod y2020;
pub mod y2021;

pub use {y2020::*, y2021::*};

/// IT MUST BE UNDER THE HOOD
#[derive(Clone, Debug, PartialEq)]
pub enum Description {
    FileTag(String),
    TestData(String),
    None,
}

/// IT MUST BE UNDER THE HOOD
#[derive(Debug, PartialEq)]
pub enum Answer<Output1: Sized + Debug + PartialEq, Output2: Sized + Debug + PartialEq> {
    Answers(Output1, Output2),
    Part1(Output1),
    Part2(Output2),
    None,
}

/// The standard interface for a problem description with solving methods
pub trait ProblemSolver<
    TargetObject: ProblemObject + Debug,
    Output1: Sized + Debug + PartialEq,
    Output2: Sized + Debug + PartialEq,
>: Debug + Sized
{
    const YEAR: usize;
    const DAY: usize;
    const DELIMITER: &'static str;
    fn default() -> Self;
    /// **TO BE IMPLEMENTED**: called by getting a new `ProblemObject` which was generated by `ProblemObject::parse`
    fn insert(&mut self, _object: TargetObject) {
        todo!("insert is not implemented")
    }
    /// UNDER THE HOOD
    fn load(desc: Description) -> Option<String> {
        fn input_filename(desc: Description, year: usize, day: usize) -> Option<String> {
            match desc {
                Description::FileTag(tag) => Some(format!("{}/input-day{:>02}-{}.txt", year, day, tag)),
                Description::None => Some(format!("{}/input-day{:>02}.txt", year, day)),
                _ => None,
            }
        }
        fn load_file(input: Option<String>) -> Option<String> {
            if let Some(fname) = input {
                let file_name = format!("data/{}", fname);
                match File::open(&file_name) {
                    Ok(mut file) => {
                        let mut contents = String::new();
                        if let Err(e) = file.read_to_string(&mut contents) {
                            panic!("Can't read {}: {:?}", fname, e);
                        }
                        println!("# loaded {}", &file_name);
                        return Some(contents);
                    }
                    Err(e) => panic!("Can't read {}: {:?}", fname, e),
                }
            }
            None
        }
        fn load_data(desc: Description) -> Option<String> {
            match desc {
                Description::TestData(s) if s.is_empty() => None,
                Description::TestData(s) => Some(s),
                _ => None,
            }
        }
        match desc {
            Description::FileTag(_) => load_file(input_filename(desc, Self::YEAR, Self::DAY)),
            Description::TestData(_) => load_data(desc),
            Description::None => load_file(input_filename(desc, Self::YEAR, Self::DAY)),
        }
    }
    /// UNDER THE HOOD.
    /// parse a structured data file, which has some 'blocks' separated with `Self::DELIMITER`
    /// then return `Self`.
    fn parse(desc: Description) -> Self {
        let mut instance = Self::default();
        if let Some(buffer) = Self::load(desc) {
            for block in buffer.split(Self::DELIMITER) {
                if let Some(element) = TargetObject::parse(block) {
                    instance.insert(element);
                }
            }
        }
        instance
    }
    /// UNDER THE HOOD
    fn run(&mut self, part: usize) -> Answer<Output1, Output2> {
        match part {
            0 => {
                println!("# Advent of Code {}: day {}, part 1", Self::YEAR, Self::DAY);
                let ans1 = self.part1();
                println!("# Advent of Code {}: day {}, part 2", Self::YEAR, Self::DAY);
                let ans2 = self.part2();
                Answer::Answers(ans1, ans2)
            }
            1 => {
                println!("# Advent of Code {}: day {}, part 1", Self::YEAR, Self::DAY);
                Answer::Part1(self.part1())
            }
            2 => {
                println!("# Advent of Code {}: day {}, part 2", Self::YEAR, Self::DAY);
                Answer::Part2(self.part2())
            }
            _ => Answer::None,
        }
    }
    /// **TO BE IMPLEMENTED**: the solver for part1
    fn part1(&mut self) -> Output1 {
        todo!("part1 is not yet implemented.")
    }
    /// **TO BE IMPLEMENTED**: the solver for part1
    fn part2(&mut self) -> Output2 {
        todo!("part2 is not yet implemented.")
    }
    /// read the input, run solver(s), return the results
    fn go(part: usize, desc: Description) {
        dbg!(Self::parse(desc).run(part));
    }
}

/// The standard interface for a data unit which corresponds to a 'block' in an input stream
pub trait ProblemObject: Debug + Sized {
    /// **TO BE IMPLEMENTED**: Parse a block then return `Option<ProblemObject>`
    fn parse(s: &str) -> Option<Self>;
}

impl ProblemObject for () {
    fn parse(_: &str) -> Option<Self> {
        None
    }
}

impl ProblemObject for String {
    fn parse(line: &str) -> Option<Self> {
        if line.is_empty() {
            None
        } else {
            Some(line.to_string())
        }
    }
}
