use std::{fmt::Debug, fs::File, io::prelude::*};
pub mod template;
pub mod y2020;
pub mod y2021;

pub use y2021::*;

/// IT MUST BE UNDER THE HOOD
#[derive(Clone, Debug, PartialEq)]
pub enum Description {
    FileTag(String),
    TestData(String),
    None,
}

/// IT MUST BE UNDER THE HOOD
#[derive(Debug, PartialEq)]
pub enum Answer<Output1: Sized + Debug + PartialEq, Output2: Sized + Debug + PartialEq> {
    Answers(Output1, Output2),
    Part1(Output1),
    Part2(Output2),
    None,
}

#[derive(Debug)]
pub struct ParseError;

impl std::convert::From<std::num::ParseIntError> for ParseError {
    fn from(_: std::num::ParseIntError) -> Self {
        todo!()
    }
}

impl std::fmt::Display for ParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "End of Stream")
    }
}

impl std::error::Error for ParseError {}

pub type Maybe<T> = Result<T, ParseError>;

/// The standard interface for a problem description with solving methods
pub trait ProblemSolver<
    TargetObject: ProblemObject + Debug,
    Output1: Sized + Debug + PartialEq,
    Output2: Sized + Debug + PartialEq,
>: Debug + Sized
{
    const YEAR: usize;
    const DAY: usize;
    const DELIMITER: &'static str;
    /// **TO BE IMPLEMENTED** return an initialized setting
    fn default() -> Self;
    /// **TO BE IMPLEMENTED**: called by getting a new `ProblemObject` which was generated by `ProblemObject::parse`
    fn insert(&mut self, _object: TargetObject) {
        todo!("insert is not implemented")
    }
    /// UNDER THE HOOD
    fn load(desc: Description) -> Maybe<String> {
        fn input_filename(desc: Description, year: usize, day: usize) -> Maybe<String> {
            match desc {
                Description::FileTag(tag) => {
                    Ok(format!("data/{}/input-day{:>02}-{}.txt", year, day, tag))
                }
                Description::None => Ok(format!("data/{}/input-day{:>02}.txt", year, day)),
                _ => Err(ParseError),
            }
        }
        fn load_file(file_name: String) -> Maybe<String> {
            match File::open(&file_name) {
                Ok(mut file) => {
                    let mut contents = String::new();
                    if let Err(e) = file.read_to_string(&mut contents) {
                        panic!("Can't read {}: {:?}", file_name, e);
                    }
                    println!("# loaded {}", &file_name);
                    Ok(contents)
                }
                Err(e) => panic!("Can't read {}: {:?}", file_name, e),
            }
        }
        fn load_data(desc: Description) -> Maybe<String> {
            match desc {
                Description::TestData(s) if s.is_empty() => Err(ParseError),
                Description::TestData(s) => Ok(s),
                _ => Err(ParseError),
            }
        }
        match desc {
            Description::FileTag(_) => load_file(input_filename(desc, Self::YEAR, Self::DAY)?),
            Description::TestData(_) => load_data(desc),
            Description::None => load_file(input_filename(desc, Self::YEAR, Self::DAY)?),
        }
    }
    /// UNDER THE HOOD.
    /// parse a structured data file, which has some 'blocks' separated with `Self::DELIMITER`
    /// then return `Self`.
    fn parse(desc: Description) -> Self {
        let mut instance = Self::default();
        if let Ok(buffer) = Self::load(desc) {
            for block in buffer.split(Self::DELIMITER) {
                if let Ok(element) = TargetObject::parse(block) {
                    instance.insert(element);
                } else {
                    dbg!(block);
                }
            }
        }
        instance
    }
    /// UNDER THE HOOD
    fn run(&mut self, part: usize) -> Answer<Output1, Output2> {
        match part {
            0 => {
                println!("# Advent of Code {}: day {}, part 1", Self::YEAR, Self::DAY);
                let ans1 = self.part1();
                println!("# Advent of Code {}: day {}, part 2", Self::YEAR, Self::DAY);
                let ans2 = self.part2();
                Answer::Answers(ans1, ans2)
            }
            1 => {
                println!("# Advent of Code {}: day {}, part 1", Self::YEAR, Self::DAY);
                Answer::Part1(self.part1())
            }
            2 => {
                println!("# Advent of Code {}: day {}, part 2", Self::YEAR, Self::DAY);
                Answer::Part2(self.part2())
            }
            _ => Answer::None,
        }
    }
    /// **TO BE IMPLEMENTED**: the solver for part1
    fn part1(&mut self) -> Output1 {
        todo!("part1 is not yet implemented.")
    }
    /// **TO BE IMPLEMENTED**: the solver for part1
    fn part2(&mut self) -> Output2 {
        todo!("part2 is not yet implemented.")
    }
    /// read the input, run solver(s), return the results
    fn go(part: usize, desc: Description) {
        dbg!(Self::parse(desc).run(part));
    }
}

/// The standard interface for a data unit which corresponds to a 'block' in an input stream
pub trait ProblemObject: Debug + Sized {
    /// **TO BE IMPLEMENTED**: Parse a block then return `Option<ProblemObject>`
    fn parse(s: &str) -> Maybe<Self>;
}

impl ProblemObject for () {
    fn parse(_: &str) -> Maybe<Self> {
        Err(ParseError)
    }
}

impl ProblemObject for usize {
    fn parse(s: &str) -> Maybe<Self> {
        s.parse::<usize>().map_err(|_| ParseError)
    }
}

impl ProblemObject for isize {
    fn parse(s: &str) -> Maybe<Self> {
        s.parse::<isize>().map_err(|_| ParseError)
    }
}

impl ProblemObject for String {
    fn parse(line: &str) -> Maybe<Self> {
        line.is_empty().then(|| line.to_string()).ok_or(ParseError)
    }
}
