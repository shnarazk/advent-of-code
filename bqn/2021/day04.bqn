Solve â‡ {envâ€¿part ğ•Š data :
  util â† â€¢Import "/util.bqn"âˆ¾Ëœ "," env.VarâŒ¾â‹ˆ "BQN_LIB"
  "â‰ seq" util.Debug â‰ seq â† util.ParseIntÂ¨"," util.Tokenize âŠ‘data
  "â‰¢grids" util.Debug â‰¢grids â† âˆ˜â€¿5â€¿5â¥Šutil.ParseIntÂ¨" " util.Tokenizeâˆ¾" "âŠ¸âˆ¾ËœÂ¨2â†“data
  n â† â‰ grids
  "numbers in grid" util.Debug â‰ â·â¥Šgrids
  ! (â¥Šgrids) â‰¡â—‹(âˆ§â·) seq
  ! 0 = âŒŠÂ´seq
  occurs â† â‹seq
  Occur â† occursâŠ‘ËœâŠ¢
  {
    1=part ?
      ogrids â† OccurÂ¨ grids
      "othr" util.Debug â¥Š=âŒœËœâ†•5
      Segments â† {âˆ¾âŸ¨<Ë˜ğ•©,<Ë˜â‰ğ•©,<(â¥Š=âŒœËœâ†•5)/â¥Šğ•©,<(â¥Š4âŠ¸=âˆ˜+âŒœËœâ†•5)/â¥Šğ•©âŸ©}
      "test" util.Debug Segments 5â€¿5â¥Šâ†•25
      SegmentsË˜grids
      # "segments" util.Debug 5â†‘needs â† SegmentsË˜grids
      # âŠ‘{winnerâ€¿len:
      #   hands â† lenâ†‘seq
      #   check â† {âˆ¨Â´{âˆ§Â´ğ•©âˆŠseq}Â¨ğ•©}Â¨needs
      #   âŸ¨1âŠcheck,len+1âŸ©
      # }â€¢_while_(n=âŠ‘)nâ€¿5
    ;
    2=part ? 0
  }
}
