Solve â‡ {envâ€¿part ğ•Š data :
  util â† â€¢Import "/util.bqn"âˆ¾Ëœ"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  âŸ¨headâŸ©â€¿rule â† (Â¯2âŠ¸Ã—++`)âˆ˜(âŸ¨âŸ©âŠ¸â‰¡Â¨)âŠ¸âŠ” data
  head -âŸœ'A'Â¨ â†©
  rule â†© 'A'-ËœÂ¨"-> "âŠ¸util.TokenizeÂ¨rule
  "head" util.Debug head
  util.Debug begin â† âŠ‘head
  "# rule" util.Debug 'A'+â‰â‰rule
  map â† (26â€¿26â†‘0){be ğ•Š m : 1âŠ¸+âŒ¾(beâŠ¸âŠ‘)m}Â´â¥Š<Ë˜2â†•head
  !(â‰ head)â‰¡1++Â´â¥Šmap
  rounds â† (2=part)â—¶âŸ¨10,40âŸ©@
  ocr â† 1âŠ¸+âŒ¾(beginâŠ¸âŠ‘)+Â´Ë˜â‰1âŠ‘{ğ•Š roundâ€¿m :
    dd â† 0
    diff â† (26â€¿26â†‘0){
      âŸ¨b,eâŸ©â€¿âŸ¨sâŸ© F d :
        t â† bâ€¿eâŠ‘m
        (tâŠ¸+)âŒ¾(sâ€¿eâŠ¸âŠ‘)(tâŠ¸+)âŒ¾(bâ€¿sâŠ¸âŠ‘)(-âŸœt)âŒ¾(bâ€¿eâŠ¸âŠ‘)d
    }Â´rule
    (â€¢Fmt round) util.Debug +Â´Ë˜m+diff
    âŸ¨1+round,m+diffâŸ©
  }â€¢_while_(roundsâŠ¸â‰¥âŠ‘)1â€¿map
  (âŒˆÂ´-âŒŠÂ´)0âŠ¸â‰ âŠ¸/ocr
}
