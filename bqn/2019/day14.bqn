Solve â‡ {envâ€¿part ğ•Š data :
  utilâ€¿âŸ¨hashmapâŸ© â† â€¢ImportÂ¨"/util.bqn"â€¿"/hashmap.bqn"âˆ¾ËœÂ¨<"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  {
    1=part ?
      "parsed" util.Debug 2â†‘â‰â‰data (Â¯2âŠ¸((â†“â‹ˆâ†‘))Â·(util.ParseIntsâŠ¸{âŸ¨âŸ©â‰¡ğ•¨ ? ğ•© ; âŠ‘ğ•¨}Â¨)(" ,=>"âŠ¸util.Tokenize))Â¨ â†©
      h â† HashmapËœâŸ¨âŸ©
      3â†‘{list ğ•Š amountâ€¿target : target h.Set amountâ‹ˆlist}Â´Â¨data
      ht â† HashmapËœâŸ¨âŸ©
      RankTree â† {ğ•¨ ğ•Š ğ•©:
        ğ•© ht.Set ğ•¨âŒˆÂ¯âˆ ht.Get ğ•©
        "ORE"â‰¢ğ•© ? (1+ğ•¨)ğ•ŠÂ¨1âŠâ‰âˆ˜â€¿2â¥Š1âŠ‘h.Get ğ•© ; @
      }
      0 RankTree "FUEL"
      "# dependency tree" util.Debug tree â† â‰â‰âŠ”Â´<Ë˜â‰>âŒ½Â¨ht.Valuesâ¼Ëœ@
      requires â† "FUEL" Hashmapâ—‹â‹ˆ 1
      {ğ•Š node :
        req â† requires.Get node
        amâ€¿ingredients â† h.Get ğ•©
        set â† âŒˆreqÃ·am
        {ğ•© requires.Set(setÃ—ğ•¨)+0 requires.Get ğ•©}Â´Ë˜âˆ˜â€¿2â¥Šingredients
      }Â¨Â¨Â¯1â†“tree
      requires.Get "ORE"
  ;
    0
  }
}
