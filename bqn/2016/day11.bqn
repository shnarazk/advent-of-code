Solve â‡ {envâ€¿part ğ•Š data :
  utilâ€¿âŸ¨hashmapâŸ©â€¿âŸ¨hashsetâŸ©â€¿âŸ¨to_heapâŸ© â† â€¢ImportÂ¨"/util.bqn"â€¿"/hashmap.bqn"â€¿"/hashset.bqn"â€¿"/heap.bqn"âˆ¾ËœÂ¨"." env.Varâ—‹< "BQN_LIB"
  "goal" util.Debug goalIndex â† Â¯1+ shape â† 4+(1+2Ã—numKinds â† {1=part ? 5 ; 7})â†‘0
  initIndex â† {1=part ? âŸ¨0,0,0,0,0,1,2,1,1,1,1âŸ© ; âŸ¨0,0,0,0,0,1,2,1,1,1,1,0,0,0,0âŸ©}
  !goalIndexâ‰¡â—‹â‰¢initIndex
  IsSafe â† {
         F state : âˆ§Â´stateâŠ¸(FËœ)Â¨â†•numKinds ;
    kind F state :
      generatorâ€¿chip â† (1â€¿2+2Ã—kind)âŠstate
      otherGenerators â† (1+2Ã—kindâŠ¸â‰ âŠ¸/â†•numKinds)âŠstate
      (generator=chip)âˆ¨(Â¬<â¼chipâˆŠotherGenerators)
  }
  ValidMove â† {(ğ•¨â‰¢ğ•©)âˆ§2â‰¥+Â´ğ•¨â‰ ğ•©}
  NextStates â† {F state :
    âŸ¨elevatorâŸ©â€¿objects â† 1(â†‘â‹ˆâ†“)state
    nextFloors â† (0âŠ¸â‰¤âˆ§4âŠ¸>)Â¨âŠ¸/Â¯1â€¿1+elevator
    IsSafeÂ¨âŠ¸/â·âˆ¾{
      floors â† elevatorâ€¿ğ•©
      âŸ¨ğ•©âŸ©<âŠ¸(âˆ¾Â¨)objectsâŠ¸ValidMoveÂ¨âŠ¸/âŸ¨âŸ¨âŸ©âŸ©{elevator=ğ•¨ ? â¥Šfloorsâˆ¾âŒœğ•© ; â¥ŠâŸ¨ğ•¨âŸ©âˆ¾âŒœğ•©}Â´objects
    }Â¨nextFloors
  }
  # distance to goal (smaller is better)
  Estimate â† {cost ğ•Š state :
    cost++Â´4â‹†Ëœ2Ã—3-state
    # cs â† 2âŠ¸|Â¨â‰ state
    # gs â† Â¬Â¨cs
    # dist â† 3-Â¨state
    # (2Ã—+Â´1â†“csÃ—dist)++Â´1â†“gsÃ—dist
  }
  {
    1=part ?
      (initIndex HashMapâ—‹â‹ˆ 0){h ğ•Š n:
        !0<â‰ s â† âˆ¾NextStatesâˆ˜âŠ‘Â¨(n=1âŠ¸âŠ‘)Â¨âŠ¸/h.Valuesâ¼Ëœ@
        util.Progress âŸ¨1+n, â‰ sâŸ©
        (1+n){ğ•¨ < âˆ h.Get ğ•© ? ğ•© h.Set ğ•¨ ; @}Â¨s
        1+n
      }â€¢_while_{Â¬ğ•¨.Has goalIndex}0 ;
    To_visit â† (<â—‹(Â¯1âŠ¸âŠ‘))_to_heap
    to_visit.Push(â‹ˆâˆ¾0âˆ¾0âŠ¸Estimate)initIndex
    min â† âˆ
    h â† {ğ•Š visited :
      iâ€¿sâ€¿e â† to_visit.Pop@
      {eâ‰¤min ? util.Progress iâ€¿sâ€¿eâ‹„ min â†© e ; @}
      {(s+1)<âˆ visited.Get ğ•© ? ğ•© visited.Set s+1 â‹„ to_visit.Push(â‹ˆâˆ¾(s+1)âˆ¾sâŠ¸Estimate)ğ•© ; @}Â¨NextStates i
      visited
    }â€¢_while_{Â¬ğ•©.Has goalIndex}initIndex Hashmapâ—‹â‹ˆ 0
    h.Get goalIndex
  }
}
