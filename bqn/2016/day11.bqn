Solve â‡ {envâ€¿part ğ•Š data :
  utilâ€¿âŸ¨hashmapâŸ©â€¿âŸ¨to_heapâŸ© â† â€¢ImportÂ¨"/util.bqn"â€¿"/hashmap.bqn"â€¿"/heap.bqn"âˆ¾ËœÂ¨"." env.Varâ—‹< "BQN_LIB"
  goalState â† Â¯1+ 4+(1+2Ã—numKinds â† {1=part ? 5 ; 7})â†‘0
  util.Debug vec â† 0âˆ¾{ğ•Š name : <â¼1âŠËœ{ğ•Š line : âˆ¨Â´nameâŠ¸â‰¡Ë˜(â‰ name)â†•line}Â¨data}Â¨âŸ¨
    "curium generator"   , "curium-compatible microchip"
    "plutonium generator", "plutonium-compatible microchip"
    "ruthenium generator", "ruthenium-compatible microchip"
    "strontium generator", "strontium-compatible microchip"
    "thulium generator"  , "thulium-compatible microchip"
âŸ©
  initState â† (2=part)â—¶âŸ¨âŠ¢,âˆ¾âŸœ0â€¿0â€¿0â€¿0âŸ©vec
  IsSafe â† {
         F state : âˆ§Â´stateâŠ¸(FËœ)Â¨â†•numKinds ;
    kind F state :
      generatorâ€¿chip â† (1â€¿2+2Ã—kind)âŠstate
      otherGenerators â† (1+2Ã—kindâŠ¸â‰ âŠ¸/â†•numKinds)âŠstate
      (generator=chip)âˆ¨(Â¬<â¼chipâˆŠotherGenerators)
  }
  ValidMove â† {(ğ•¨â‰¢ğ•©)âˆ§2â‰¥+Â´ğ•¨â‰ ğ•©}
  NextStates â† {F state :
    âŸ¨elevatorâŸ©â€¿objects â† 1(â†‘â‹ˆâ†“)state
    nextFloors â† (0âŠ¸â‰¤âˆ§4âŠ¸>)Â¨âŠ¸/Â¯1â€¿1+elevator
    IsSafeÂ¨âŠ¸/â·âˆ¾{
      floors â† elevatorâ€¿ğ•©
      âŸ¨ğ•©âŸ©<âŠ¸(âˆ¾Â¨)objectsâŠ¸ValidMoveÂ¨âŠ¸/âŸ¨âŸ¨âŸ©âŸ©{elevator=ğ•¨ ? â¥Šfloorsâˆ¾âŒœğ•© ; â¥ŠâŸ¨ğ•¨âŸ©âˆ¾âŒœğ•©}Â´objects
    }Â¨nextFloors
  }
  Estimate â† {cost ğ•Š state : cost+1.5â‹†+Â´3-âŒŠÂ´Ë˜âˆ˜â€¿2â¥Š1â†“state}    # distance to goal (smaller is better)
  To_visit â† (<â—‹(Â¯1âŠ¸âŠ‘))_to_heap
  to_visit.Push(â‹ˆâˆ¾0âˆ¾0âŠ¸Estimate)initState
  min â† âˆ
  {ğ•©.Get goalState}{ğ•Š visited :
    iâ€¿sâ€¿e â† to_visit.Pop@
    {eâ‰¤min ? util.Progress iâ€¿sâ€¿eâ‹„ min â†© e ; @}
    (s+1){ğ•¨<âˆ visited.Get ğ•© ? ğ•© visited.Set ğ•¨ â‹„ to_visit.Push(â‹ˆâˆ¾ğ•¨âˆ¾sâŠ¸Estimate)ğ•© ; @}Â¨NextStates i
    visited
  }â€¢_while_{Â¬ğ•©.Has goalState}initState Hashmapâ—‹â‹ˆ 0
}
