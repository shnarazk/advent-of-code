#!/usr/bin/env cbqn

Solve â‡ {envâ€¿part ğ•Š data :
  util â† â€¢Import "/util.bqn"âˆ¾Ëœ"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  "goal" util.Debug goalIndex â† Â¯1+ shape â† 4+{1=part ? 5 ; 9}â†‘0
  initIndex â† {1=part ? 0â€¿1â€¿0â€¿2â€¿0 ; 0â€¿1â€¿0â€¿2â€¿0â€¿0â€¿0â€¿0â€¿0}
  "v" util.Debug â‰¢v â† âˆÂ¨â†•shape
  numKinds â† {1=part ? 2 ; 4}
  v 0âŒ¾(initIndexâŠ¸âŠ‘) â†©
  !âˆ=goalIndexâŠ‘v
  # FIXME
  NextObjectsStates â† {F state :
    Mask â† {(Â¯2Ã—numKinds)â†‘{ F 0 : âŸ¨0âŸ© ; F n : {(F(n-ğ•©)Ã·2)âˆ¾ğ•©}2|n }ğ•©}
    objects â† {(âŠ‘ğ•©)âŠ¸=Â¨1â†“ğ•©}state
    blank â† 0Ë™Â¨1â†“state
    indexes â† objects/âŠ¢Ã—âŸœ(â†•âˆ˜â‰ )objects
    cands â† âŸ¨âŸ©
    {F i :
      cand â† 1Ë™âŒ¾(iâŠ¸âŠ‘)blank
      { F j : iâ‰¤j ? candsâˆ¾â†© <1Ë™âŒ¾(jâŠ¸âŠ‘)cand ; @}Â¨indexes
    }Â¨indexes
    cands
  }
  IsSafe â† {
         F state : âˆ§Â´stateâŠ¸(FËœ)Â¨â†•numKinds ;
    kind F state :
      generatorâ€¿chip â† (1â€¿2+2Ã—kind)âŠstate
      otherGenerators â† (1+2Ã—kindâŠ¸â‰ âŠ¸/â†•numKinds)âŠstate
      (generator=chip)âˆ¨(Â¬<â¼chipâˆŠotherGenerators)
  }
  # FIXME
  NextStates â† {F state :
    elevator â† âŠ‘state
    objects â† 1â†“state
    nextFloors â† {(0â‰¤ğ•©)âˆ§(ğ•©<4)}Â¨âŠ¸/âŸ¨Â¯1+elevator,1+elevatorâŸ©
    cands â† â¥Š nextFloors{ğ•¨âˆ¾((Â¬ğ•©)Ã—objects)+ğ•¨Ã—ğ•©}âŒœNextObjectsStates state
    IsSafeÂ¨âŠ¸/cands
  }
  {ğ•Š n: {v (n+1)âŠ¸âŒŠâŒ¾(ğ•©âŠ¸âŠ‘) â†©}Â¨âˆ¾NextStatesÂ¨(n=âŠ‘âŸœv)Â¨âŠ¸/â¥Šâ†•â‰¢v â‹„ 1+n}â€¢_while_{ğ•¤â‹„ âˆ=goalIndexâŠ‘v}0
}
