Solve â‡ {envâ€¿part ğ•Š data :
  utilâ€¿âŸ¨hashmapâŸ© â† â€¢ImportÂ¨"/util.bqn"â€¿"/hashmap.bqn"âˆ¾ËœÂ¨"." env.Varâ—‹< "BQN_LIB"
  "goal" util.Debug goalIndex â† Â¯1+ shape â† 4+(1+2Ã—numKinds â† {1=part ? 5 ; 7})â†‘0
  initIndex â† {1=part ? âŸ¨0,0,0,0,0,1,2,1,1,1,1âŸ© ; âŸ¨0,0,0,0,0,1,2,1,1,1,1,0,0,0,0âŸ©}
  !goalIndexâ‰¡â—‹â‰¢initIndex
  IsSafe â† {
         F state : âˆ§Â´stateâŠ¸(FËœ)Â¨â†•numKinds ;
    kind F state :
      generatorâ€¿chip â† (1â€¿2+2Ã—kind)âŠstate
      otherGenerators â† (1+2Ã—kindâŠ¸â‰ âŠ¸/â†•numKinds)âŠstate
      (generator=chip)âˆ¨(Â¬<â¼chipâˆŠotherGenerators)
  }
  ValidMove â† {(ğ•¨â‰¢ğ•©)âˆ§2â‰¥+Â´ğ•¨â‰ ğ•©}
  NextStates â† {F state :
    âŸ¨elevatorâŸ©â€¿objects â† 1(â†‘â‹ˆâ†“)state
    nextFloors â† (0âŠ¸â‰¤âˆ§4âŠ¸>)Â¨âŠ¸/Â¯1â€¿1+elevator
    IsSafeÂ¨âŠ¸/â·âˆ¾{
      floors â† elevatorâ€¿ğ•©
      âŸ¨ğ•©âŸ©<âŠ¸(âˆ¾Â¨)objectsâŠ¸ValidMoveÂ¨âŠ¸/âŸ¨âŸ¨âŸ©âŸ©{elevator=ğ•¨ ? â¥Šfloorsâˆ¾âŒœğ•© ; â¥ŠâŸ¨ğ•¨âŸ©âˆ¾âŒœğ•©}Â´objects
    }Â¨nextFloors
  }
  (initIndex HashMapâ—‹â‹ˆ 0){h ğ•Š n:
    !0<â‰ s â† âˆ¾NextStatesâˆ˜âŠ‘Â¨(n=1âŠ¸âŠ‘)Â¨âŠ¸/h.Valuesâ¼Ëœ@
    util.Progress âŸ¨1+n, â‰ sâŸ©
    (1+n){ğ•¨ < âˆ h.Get ğ•© ? ğ•© h.Set ğ•¨ ; @}Â¨s
    1+n
  }â€¢_while_{Â¬ğ•¨.Has goalIndex}0
}
