Solve â‡ {envâ€¿part ğ•Š data :
  util â† â€¢Import "/util.bqn"âˆ¾Ëœ"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  "goal" util.Debug goalIndex â† Â¯1+ shape â† 4+{1=part ? 11 ; 15}â†‘0
  initIndex â† {1=part ? âŸ¨0,0,0,0,0,1,2,1,1,1,1âŸ© ; âŸ¨0,0,0,0,0,1,2,1,1,1,1,0,0,0,0âŸ©}
  "v" util.Debug â‰¢v â† âˆÂ¨â†•shape
  numKinds â† {1=part ? 2 ; 4}
  v 0âŒ¾(initIndexâŠ¸âŠ‘) â†©
  !âˆ=goalIndexâŠ‘v
  IsSafe â† {
         F state : âˆ§Â´stateâŠ¸(FËœ)Â¨â†•numKinds ;
    kind F state :
      generatorâ€¿chip â† (1â€¿2+2Ã—kind)âŠstate
      otherGenerators â† (1+2Ã—kindâŠ¸â‰ âŠ¸/â†•numKinds)âŠstate
      (generator=chip)âˆ¨(Â¬<â¼chipâˆŠotherGenerators)
  }
  ValidMove â† {a ğ•Š b : (aâ‰¢b)âˆ§2â‰¥+Â´aâ‰ b }
  NextStates â† {F state :
    âŸ¨elevatorâŸ©â€¿objects â† 1(â†‘â‹ˆâ†“)state
    nextFloors â† (0âŠ¸â‰¤âˆ§4âŠ¸>)Â¨âŠ¸/Â¯1â€¿1+elevator
    IsSafeÂ¨âŠ¸/â·âˆ¾{floors â† elevatorâ€¿ğ•© â‹„ âŸ¨ğ•©âŸ©<âŠ¸(âˆ¾Â¨)objectsâŠ¸ValidMoveÂ¨âŠ¸/âŸ¨âŸ¨âŸ©âŸ©{elevator=ğ•¨ ? â¥Šfloorsâˆ¾âŒœğ•© ; â¥ŠâŸ¨ğ•¨âŸ©âˆ¾âŒœğ•©}Â´objects}Â¨nextFloors
  }
  {ğ•Š n:
    util.Progress n
    s â† âˆ¾NextStatesÂ¨(n=âŠ‘âŸœv)Â¨âŠ¸/â¥Šâ†•â‰¢v
    !0<â‰ s
    {v (n+1)âŠ¸âŒŠâŒ¾(ğ•©âŠ¸âŠ‘) â†©}Â¨s
    1+n}â€¢_while_{ğ•¤â‹„ âˆ=goalIndexâŠ‘v}0
}
