_under_ â† {
    ğ”½ _ğ•£_ ğ”¾ ğ•© :  ğ”½ğ”¾ğ•© â‹„ ğ•© ;
  ğ•¨ ğ”½ _ğ•£_ ğ”¾ ğ•© : ğ•¨ğ”½ğ”¾ğ•© â‹„ ğ•©
}
Solve â‡ {envâ€¿part ğ•Š data :
  utilâ€¿geo â† â€¢ImportÂ¨"/util.bqn"â€¿"/geometry.bqn"âˆ¾ËœÂ¨<"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  Distance â† {(âŠ¢âŒŠğ•¨{ğ•¨â—¶âŸ¨âˆ,âŠ¢âŸ©ğ•©}Â¨(1+âŒŠÂ´Â¨âˆ˜(âˆâŠ¸geo.Neighbor4)))âŸ(2Ã—(â‰ ğ•¨))ğ•© geo.Rotate 0âŒ¾(0â€¿0âŠ¸âŠ‘)âˆÂ¨ğ•¨}
  symbols â† ".#EG"
  data symbolsâŠ¸âŠâˆ˜> â†©
  blocks â† (1=âŠ‘âŸœdata)Â¨â†•â‰¢data
  elf_hitpoint â† 3
  goblin_hitpoint â† 3
  "â‰ elves" util.Debug â‰ elves â† {âŸ¨ğ•©,2,elf_hitpointâŸ©}Â¨(2=âŠ‘âŸœdata)Â¨âŠ¸/â¥Šâ†•â‰¢data
  "â‰ goblins" util.Debug â‰ goblins â† {âŸ¨ğ•©,3,goblin_hitpointâŸ©}Â¨(3=âŠ‘âŸœdata)Â¨âŠ¸/â¥Šâ†•â‰¢data
  chars â† elvesâˆ¾goblins
  shape â† â‰¢data
  Show â† {
    ğ•Š ğ•© : 2==ğ•© ? âˆ§Â´â¥Š((3âŠ¸â‰¥)âˆ§1=â€¢Type)Â¨ğ•© ? util.Debug âŠ‘âŸœsymbolsÂ¨ğ•© â‹„ ğ•©  ;
    ğ•Š ğ•© : 2==ğ•© ? â€¢Show ğ•© â‹„ ğ•©  ;
    ğ•Š ğ•© : 1==ğ•© ? 8<â‰ ğ•© ? âˆ§Â´â‰¡â—‹â‰ Â´Ë˜2â†•ğ•© ? util.Debug â‰â‰ğ•© â‹„ ğ•©  ;
    ğ•Š ğ•© : util.Debug ğ•© ;
    ğ•¨ ğ•Š ğ•© :
      2==ğ•© ? âˆ§Â´â¥Š((3âŠ¸â‰¥)âˆ§1=â€¢Type)Â¨ğ•© ? ğ•¨ util.Debug âŠ‘âŸœsymbolsÂ¨ğ•© â‹„ ğ•©  ;
      2==ğ•© ? ğ•¨ util.Debug ğ•© â‹„ ğ•©  ;
      1==ğ•© ? 8<â‰ ğ•© ? âˆ§Â´â‰¡â—‹â‰ Â´Ë˜2â†•ğ•© ? ğ•¨ util.Debug â‰â‰ğ•© â‹„ ğ•© ;
      1    ? ğ•¨ util.Debug ğ•©
  }
  Act â† {chars ğ•Š iâ€¿map :
    posâ€¿speciesâ€¿hitpoint â† iâŠ‘chars
    "enemytype" Show enemytype â† Â¬âŒ¾(-âŸœ2)species
    âŸ¨âŸ©â‰¢targets â† (enemytype=1âŠ¸âŠ‘)Â¨âŠ¸/chars ?
    enemymap â† âˆŠâŸœ(âŠ‘Â¨targets)â†•shape
    "rot" Show 4âŠ¸â†‘ rangeoftargets â† âˆ§â·âˆ¾â¥Šenemymap{ğ•¨â—¶âŸ¨âŸ¨âŸ©,âŠ¢âŸ©ğ•©}Â¨âˆâŠ¸â‰¢Â¨âŠ¸/Â¨âˆ geo.Neighbor8 â†•shape
    (need_to_move â† âˆ¨Â´(0=âŠ‘âŸœdata)Â¨rangeoftargets)âˆ¨(âˆŠâŸœrangeoftargetsâŒ¾â‹ˆpos) ?
    destination â† pos
    {
      need_to_move ?
        d â† pos DistanceËœ0=map
        "destination" Show destination â†© âŸ¨âŸ©âŠ¸â‰¢â—¶âŸ¨âŠ¢,1âŠ¸âŠ‘âŠ‘âŸ©âˆ§(âˆâ‰ âŠ‘)Â¨âŠ¸/{ğ•©â‹ˆËœğ•©âŠ‘d}Â¨rangeoftargets
      ; @
    }
    âŸ¨âŸ©â‰¢destination ?
    # attack
      # To attack, the unit first determines all of the targets that
      # are in range of it by being immediately adjacent to it.
      # If there are no such targets, the unit ends its turn.
      # Otherwise, the adjacent target with the fewest hit points is
      # selected; in a tie, the adjacent target with the fewest hit
      # points which is first in reading order is selected.
    adjacent â† geo.Neighbor8 pos
    âŸ¨âŸ©â‰¢attackabletargets â† âˆŠâŸœadjacentâŠ¸/targets ?
    order â† â‹(2â€¿0â€¿1âŠ¸âŠ)attackabletargets
    target â† attackabletargetsâŠ‘ËœâŠ‘order
    ;
      @
  }
  "test act" Show chars Act 0â‹ˆdata
  {
    1=part ?
      {ğ•Š turn:
        order â† â‹chars
        {ğ•Š nth :
           {
            âˆ : @ ;
            ğ•© : @
          }nthâŠ‘chars
        }Â¨order
        0
      }â€¢_while_(âŠ¢)1
      0 ;
    0
  }
}
