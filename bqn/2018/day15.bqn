Solve â‡ {envâ€¿part ğ•Š data :
  utilâ€¿geo â† â€¢ImportÂ¨"/util.bqn"â€¿"/geometry.bqn"âˆ¾ËœÂ¨<"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  Distance â† {(âŠ¢âŒŠğ•¨{ğ•¨â—¶âŸ¨âˆ,âŠ¢âŸ©ğ•©}Â¨(1+âŒŠÂ´Â¨âˆ˜(âˆâŠ¸geo.Neighbor4)))âŸ(2Ã—(â‰ ğ•¨))(-ğ•©) geo.Rotate 0âŒ¾(0â€¿0âŠ¸âŠ‘)âˆÂ¨ğ•¨}
  symbols â† ".#EG"
  shape â† â‰¢data symbolsâŠ¸âŠâˆ˜>âˆ˜(âŸ¨âŸ©âŠ¸â‰¢Â¨âŠ¸/)âˆ˜(' 'âŠ¸â‰ Â¨âŠ¸/Â¨) â†©
  blocks â† (1=âŠ‘âŸœdata)Â¨â†•â‰¢data
  elf_attack_powerâ€¿goblin_attack_powerâ€¿hitpoint â† 3â€¿3â€¿200
  chars â† â†•âˆ˜â‰ âŠ¸(â‹ˆâŠ¸âˆ¾Â¨){
    elves â† {âŸ¨ğ•©,2,hitpointâŸ©}Â¨(2=âŠ‘âŸœdata)Â¨âŠ¸/â¥Šâ†•â‰¢data
    goblins â† {âŸ¨ğ•©,3,hitpointâŸ©}Â¨(3=âŠ‘âŸœdata)Â¨âŠ¸/â¥Šâ†•â‰¢data
    elvesâˆ¾goblins
  }
  # CurrentMap â† {blocks{iâ€¿posâ€¿sâ€¿hp ğ•Š ğ•©: (0<hp)â—¶âŸ¨âŠ¢,sâŒ¾(posâŠ¸âŠ‘)âŸ©ğ•©}Â´ğ•©}
  ended â† 0
  Act â† {
    i ğ•Š chars  :
      idâ€¿posâ€¿speciesâ€¿hitpoint â† iâŠ‘chars
      0<hitpoint ?
      enemytype â† Â¬âŒ¾(-âŸœ2)species
      livings â† (0<3âŠ¸âŠ‘)Â¨âŠ¸/chars
      pol â† 1âŠ¸âŠ‘Â¨livings
      current_open â† 1âŒ¾(posâŠ¸âŠ‘)Â¬((âˆŠâŸœpolâŒ¾â‹ˆ)âˆ¨(âŠ‘âŸœblocks))Â¨â†•shape
      targets â† (enemytype=2âŠ¸âŠ‘)Â¨âŠ¸/livings
      {âŸ¨âŸ©â‰¢targets ? ended â†© 1 ; @}
      âŸ¨âŸ©â‰¢targets ?
      enemymap â† âˆŠâŸœ(1âŠ¸âŠ‘Â¨targets)â†•shape
      rangeoftargets â† âˆ§â·âˆ¾â¥Šenemymap{ğ•¨â—¶âŸ¨âŸ¨âŸ©,âŠ¢âŸ©ğ•©}Â¨âˆâŠ¸â‰¢Â¨âŠ¸/Â¨âˆ geo.Neighbor4 â†•shape
      {
        âˆŠâŸœrangeoftargetsâŒ¾â‹ˆpos ? @
        ;
          destination â† pos
          {
            Â¬âˆŠâŸœrangeoftargetsâŒ¾â‹ˆpos ?
            d â† current_open Distance pos
            destination â†© âŸ¨âŸ©âŠ¸â‰¢â—¶âŸ¨âŠ¢,1âŠ¸âŠ‘âŠ‘âŸ©âˆ§(âˆâ‰ âŠ‘)Â¨âŠ¸/{ğ•©â‹ˆËœğ•©âŠ‘d}Â¨rangeoftargets
            ; @
          }
          âŸ¨âŸ©â‰¢destination ?
          path â† current_open Distance destination
          pos â†© 1âŠ‘âŠ‘âˆ§(âŠ‘âŸœpath)âŠ¸â‹ˆÂ¨(âŠ‘âŸœcurrent_open)Â¨âŠ¸/âˆâŠ¸â‰¢Â¨âŠ¸/posâŠ‘âˆ geo.Neighbor4 â†•shape
          chars posâŒ¾(1âŠ¸âŠ‘idâŠ¸âŠ‘) â†©
          ; @
      }
      adjacents â† âˆâŠ¸â‰¢âŠ¸/posâŠ‘âˆ geo.Neighbor4 â†•shape
      {
        âŸ¨âŸ©â‰¢attackabletargets â† ((âˆŠâŸœadjacents)âŒ¾â‹ˆ1âŠ¸âŠ‘)Â¨âŠ¸/targets ?
        target â† attackabletargetsâŠ‘ËœâŠ‘â‹(3â€¿1âŠ¸âŠ)Â¨attackabletargets
        p â† (2âŠ¸=)â—¶âŸ¨goblin_attack_power,elf_attack_powerâŸ©species
        chars (0âŒˆ-âŸœp)âŒ¾(3âŠ¸âŠ‘(âŠ‘target)âŠ¸âŠ‘) â†©
        ; @
      }
      chars
      ;
    ğ•¨ ğ•Š ğ•© : ğ•©
  }
  {
    1=part ?
      (-âŸœended)âŠ¸Ã—âŸœ(âŒˆÂ´)Â´{turnâ€¿points:
        chars â†© chars ActÂ´â’(1âŠ¸âŠ‘)Â¨chars
        ep â† +Â´(3âŠ¸âŠ‘)Â¨(2=2âŠ¸âŠ‘)Â¨âŠ¸/chars
        gp â† +Â´(3âŠ¸âŠ‘)Â¨(3=2âŠ¸âŠ‘)Â¨âŠ¸/chars
        âŸ¨turn+1,util.Progress epâ‹ˆgpâŸ©
      }â€¢_while_(0<âŒŠÂ´âˆ˜(1âŠ¸âŠ‘))âŸ¨0,1â€¿1âŸ©
    ;
      initial_chars â† chars
      2âŠ‘{minâ€¿maxâ€¿outcome :
        util.Progress ğ•©
        mid â† âŒŠ2Ã·Ëœmin+max
        charsâ€¿elf_attack_powerâ€¿ended â†© initial_charsâ€¿midâ€¿0
        result â† {turnâ€¿points :
          chars â†© chars ActÂ´â’(1âŠ¸âŠ‘)Â¨chars
          ep â† +Â´(3âŠ¸âŠ‘)Â¨(2=2âŠ¸âŠ‘)Â¨âŠ¸/chars
          gp â† +Â´(3âŠ¸âŠ‘)Â¨(3=2âŠ¸âŠ‘)Â¨âŠ¸/chars
          âŸ¨turn+1,(epÃ—âˆ§Â´(0<3âŠ¸âŠ‘)Â¨(2=2âŠ¸âŠ‘)Â¨âŠ¸/chars)â‹ˆgpâŸ©
        }â€¢_while_(0<âŒŠÂ´âˆ˜(1âŠ¸âŠ‘))âŸ¨0,1â€¿1âŸ©
        {âˆ§Â´(0<3âŠ¸âŠ‘)Â¨(2=2âŠ¸âŠ‘)Â¨âŠ¸/chars ? âŸ¨min,mid,(-âŸœended)âŠ¸Ã—âŸœ(âŒˆÂ´)Â´resultâŸ© ; âŸ¨mid,max,outcomeâŸ©}
      }â€¢_while_(1<(-ËœÂ´2âŠ¸â†‘))4â€¿300â€¿0
  }
}
