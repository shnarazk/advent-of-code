Solve â‡ {envâ€¿part ğ•Š data :
  utilâ€¿geo â† â€¢ImportÂ¨"/util.bqn"â€¿"/geometry.bqn"âˆ¾ËœÂ¨<"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  data ".#EG"âŠ¸âŠâˆ˜> â†©
  blocks â† (1=âŠ‘âŸœdata)Â¨â†•â‰¢data
  elf_hitpoint â† 3
  goblin_hitpoint â† 3
  elves â† {âŸ¨ğ•©,2,elf_hitpointâŸ©}Â¨(2=âŠ‘âŸœdata)Â¨âŠ¸/â¥Šâ†•â‰¢data
  goblins â† {âŸ¨ğ•©,2,goblin_hitpointâŸ©}Â¨(3=âŠ‘âŸœdata)Â¨âŠ¸/â¥Šâ†•â‰¢data
  util.Debug chars â† elvesâˆ¾goblins
  map â† â‰¢data
  util.Debug (âˆŠâŸœ(â†•10))âŒ¾â‹ˆ 1
  Act â† {chars ğ•Š i:
     posâ€¿speciesâ€¿hitpoint â† iâŠ‘chars
    enemytype â† Â¬âŒ¾(-âŸœ2)species
    enemies â† (enemytypeâŠ¸=)Â¨âŠ¸/chars
    {
      âŸ¨âŸ©â‰¡enemies ? @
      ;
        enemymap â† âˆŠâŸœ(âŠ‘Â¨enemies)âŒ¾â‹ˆÂ¨âŠ¸/â†•map
        rangeoftargets â† â·enemymapÃ—geo.Neighbor8Â¨â†•map
        {
          (âˆ¨Â´(0=âŠ‘âŸœdata)Â¨rangeoftargets)âˆ§(Â¬âˆŠâŸœrangeoftargetsâŒ¾â‹ˆpos) ? @ ;
           # move
          {
            âˆŠâŸœrangeoftargetsâŒ¾â‹ˆpos ?
               "move"
            ; @
          }
          # attack
          adjacent â† geo.Neighbor8 pos
          {
            âŸ¨âŸ©â‰¢attackabletargets â† âˆŠâŸœadjacentâŠ¸/enemies ?
              order â† â‹(2â€¿0â€¿1âŠ¸âŠ)attackabletargets
              target â† attackabletargetsâŠ‘ËœâŠ‘order
            ;
              @
          }
        }
    }
  }
  {
    1=part ?
      {ğ•Š turn:
        order â† â‹chars
        {ğ•Š nth :
           {
            âˆ : @ ;
            ğ•© : @
          }nthâŠ‘chars
        }Â¨order
        0
      }â€¢_while_(âŠ¢)1
      0 ;
    0
  }
}
