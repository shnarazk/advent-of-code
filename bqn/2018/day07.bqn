Solve â‡ {envâ€¿part ğ•Š data :
  utilâ€¿âŸ¨hashmapâŸ© â† â€¢ImportÂ¨"/util.bqn"â€¿"/hashmap.bqn"âˆ¾ËœÂ¨<"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  data (-âŸœ'A'âˆ˜âŠ‘Â¨Â·1â€¿7âŠ¸âŠ" "âŠ¸util.Split)Â¨ â†©
  p â† HashmapËœâŸ¨âŸ© # map from node to parents
  {ğ•¨ p.Setâˆ§âŸ¨ğ•©âŸ©âˆ¾âŸ¨âŸ© p.Get ğ•¨}ËœÂ´Â¨data
  children â† â·p.Valuesâ¼@
  roots â† (Â¬âˆŠâŸœchildren)âŠ¸/â†•26
  p.SetâŸœâŸ¨âŸ©Â¨roots
  {
    1=part ?
      'A'+1âŠ‘{candsâ€¿seq :
        next â† âŠ‘âˆ§(âˆ§Â´Â·(âˆŠâŸœseq)p.Get)Â¨âŠ¸/cands
        âŸ¨nextâŠ¸â‰ Â¨âŠ¸/cands,seqâˆ¾nextâŸ©
      }â€¢_while_(âŸ¨âŸ©â‰¢âŠ‘)(â†•26)â€¿âŸ¨âŸ©
      ;
    r â† {secondsâ€¿remainâ€¿shift :
      # purge finished tasks then check if there are executable tasks now
      unfinished â† remainâˆ¾â·1âŠ¸âŠ‘Â¨ shift (0â‰ âŠ‘)â—¶âŸ¨0â€¿âˆ,âŠ¢âŸ©Â¨ â†©
      executables â† (Â¬Â·âˆ¨Â´Â·(âˆŠâŸœunfinished)p.Get)Â¨âŠ¸/remain
      {
        âŸ¨âŸ©â‰¢executables ?
        task â† âŠ‘âˆ§executables
        workerIndex â† ((0=âŠ‘)âˆ¨(âˆ=1âŠ¸âŠ‘))Â¨shift
        âˆ¨Â´workerIndex ?
          workerIndex {ğ•©âŠ¸âŠâŒ¾â‹ˆ1} â†©
          âŸ¨seconds,taskâŠ¸â‰ Â¨âŠ¸/remain,âŸ¨61+task,taskâŸ©âŒ¾(workerIndexâŠ¸âŠ‘)shiftâŸ©
        ;
        # otherwise go forward to the time a task is finished
        elapse â† âŠ‘âŠ‘âˆ§(âˆâ‰ 1âŠ¸âŠ‘)Â¨âŠ¸/shift
        âŸ¨seconds+elapse,remain,{âŸ¨0âŒˆğ•¨-elapse,ğ•©âŸ©}Â´Â¨shiftâŸ©
      }
    }â€¢_while_(âŸ¨âŸ©â‰¢1âŠ¸âŠ‘)âŸ¨0,â†•26,0â€¿âˆÂ¨â†•5âŸ©
    (âŠ‘r)+âŒˆÂ´âŠ‘Â¨2âŠ‘r
  }
}
