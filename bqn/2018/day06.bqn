Solve â‡ {envâ€¿part ğ•Š data :
  utilâ€¿geoâ€¿âŸ¨hashmapâŸ© â† â€¢ImportÂ¨"/util.bqn"â€¿"/geometry.bqn"â€¿"/hashmap.bqn"âˆ¾ËœÂ¨<"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  minâ€¿max â† (âŒŠÂ´â‹ˆâŒˆÂ´) data util.ParseIntsÂ¨ â†©
  kind â† â‰ data
  {
    1=part ?
      m â† 1âŠ‘âŸ¨1,âˆÂ¨â†•maxÂ¬minâŸ©{d ğ•Š kâ€¿m : âŸ¨1+k, kâŒ¾((d-min)âŠ¸âŠ‘)mâŸ©}Â´data
      f â† {{âˆ=âŠ‘ğ•© ? {âŸ¨âŸ© : âˆ ; âŸ¨aâŸ© : a ; ğ•© : 0}â·âˆâŠ¸â‰ âŠ¸/ğ•© ; âŠ‘ğ•©}Â¨âˆ geo.Neighbor5 ğ•©}â€¢_while_(âˆ¨Â´âˆ=â¥Š)m
      k â† âˆ§â·(1â€¿Â¯1âŠâ‰f)âˆ¾â—‹â¥Š(1â€¿Â¯1âŠf)
      âŒˆÂ´(Â¬(âˆŠâŸœkâŒ¾â‹ˆ)Â¨â†•1+kind)âŠ¸//â¼â¥Šf
      ;
    limit â† 10000
    Within â† {limit>+Â´(+â—‹|Â´-âŸœğ•©)Â¨data}
    !Within cand â† âŒŠ50Ã·Ëœ+Â´data
    visited â† cand Hashmapâ—‹â‹ˆ 1
    {ğ•Š cands :
      âŸ¨câŸ©â€¿r â† 1(â†‘â‹ˆâ†“) cands
      util.Progress visited.Count@
      {
        visited.Has c ? @ ;
        c visited.Set ok â† WithIn c
        ok ?
          n â† Â¬âˆ˜visited.HasÂ¨âŠ¸/c<âŠ¸+âŸ¨Â¯1â€¿0,0â€¿1,1â€¿0,0â€¿Â¯1âŸ©
          r nâŠ¸âˆ¾ â†©
        ; @
      }
      r
    }â€¢_while_(âŸ¨âŸ©âŠ¸â‰¢)cand<âŠ¸+âŸ¨Â¯1â€¿0,0â€¿1,1â€¿0,0â€¿Â¯1âŸ©
    +Â´visited.Values@
  }
}
