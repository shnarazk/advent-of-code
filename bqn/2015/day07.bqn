Solve â‡ {envâ€¿part ğ•Š data :
  utilâ€¿âŸ¨hashmapâŸ© â† â€¢ImportÂ¨"/util.bqn"â€¿"/hashmap.bqn"âˆ¾ËœÂ¨<"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  data ((âˆ§Â´âˆŠâŸœ"0123456789")â—¶âŸ¨âŠ¢,util.ParseIntâŸ©Â¨ " "âŠ¸util.Tokenize)Â¨ â†©
  h â† HashmapËœâŸ¨âŸ©
  cached â† HashmapËœâŸ¨âŸ©
  notâ€¿andâ€¿orâ€¿lsfâ€¿rsf â† â†•5
  Inject â† {
    o1â€¿"->"    â€¿d        : d h.Set o1 ;
       "NOT"   â€¿o1â€¿arrâ€¿d : d h.Set notâ€¿o1 ;
    o1â€¿"AND"   â€¿o2â€¿arrâ€¿d : d h.Set andâ€¿o1â€¿o2 ;
    o1â€¿"OR"    â€¿o2â€¿arrâ€¿d : d h.Set orâ€¿o1â€¿o2 ;
    o1â€¿"LSHIFT"â€¿o2â€¿arrâ€¿d : d h.Set lsfâ€¿o1â€¿o2 ;
    o1â€¿"RSHIFT"â€¿o2â€¿arrâ€¿d : d h.Set rsfâ€¿o1â€¿o2 ;
    ğ•© ! 0
  }
  ToBits â† {ğ•Š x : 32â€¿1â€¢bit._castâ‹ˆğ•© ; ğ•Šâ¼ x : âŠ‘âŸ¨1,32âŸ©â€¢bit._cast 32â†‘16â†‘ğ•©}
  Eval â† {
    0â€¿a   : "not" util.Debug ğ•© â‹„ 1â€¿1â€¢bit._notâŒ¾ToBits ğ•Š a ;
    1â€¿aâ€¿b : "and" util.Debug ğ•© â‹„ ToBitsâ¼a(1â€¿1â€¢bit._andâ—‹(ToBitsâˆ˜ğ•Š))b ;
    2â€¿aâ€¿b : "or " util.Debug ğ•© â‹„ ToBitsâ¼a(1â€¿1â€¢bit._orâ—‹(ToBitsâˆ˜ğ•Š))b ;
    3â€¿aâ€¿b : "lft" util.Debug ğ•© â‹„ Â»âŸbâŒ¾ToBits ğ•Š a ;
    4â€¿aâ€¿b : "rft" util.Debug ğ•© â‹„ Â«âŸbâŒ¾ToBits ğ•Š a ;
      ğ•Š a : cached.Has a ? cached.Get a ;
      ğ•Š a : 1=â€¢Type a ? a ;
      ğ•Š a : a cached.Set x â† ğ•Š h.Get a â‹„ ("ref "âˆ¾a) util.Debug x
  }
  {
    1=part ?
      InjectÂ¨data
      {h.Has ğ•© ? Eval ğ•© ; @}Â¨"a"â€¿"f"â€¿"g"â€¿"h"â€¿"i"â€¿"d"â€¿"e"
      cached.Get "a"
      ;
    InjectÂ¨data
    b â† Eval "a"
    h â†© HashmapËœâŸ¨âŸ©
    InjectÂ¨data
    "b" h.Set b
    cached â†© HashmapËœâŸ¨âŸ©
    Eval "a"
  }
}
