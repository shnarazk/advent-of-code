Solve â‡ {envâ€¿part ğ•Š data :
  utilâ€¿âŸ¨hashmapâŸ© â† â€¢ImportÂ¨"/util.bqn"â€¿"/hashmap.bqn"âˆ¾ËœÂ¨<"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  data ((âˆ§Â´âˆŠâŸœ"0123456789")â—¶âŸ¨âŠ¢,util.ParseIntâŸ©Â¨ " "âŠ¸util.Tokenize)Â¨ â†©
  h â† HashmapËœâŸ¨âŸ©
  cached â† HashmapËœâŸ¨âŸ©
  notâ€¿andâ€¿orâ€¿lsfâ€¿rsf â† â†•5
  Inject â† {
    ğ•¨ ğ•Š o1â€¿"->"    â€¿d        : d ğ•¨.Set o1 ;
    ğ•¨ ğ•Š    "NOT"   â€¿o1â€¿arrâ€¿d : d ğ•¨.Set notâ€¿o1 ;
    ğ•¨ ğ•Š o1â€¿"AND"   â€¿o2â€¿arrâ€¿d : d ğ•¨.Set andâ€¿o1â€¿o2 ;
    ğ•¨ ğ•Š o1â€¿"OR"    â€¿o2â€¿arrâ€¿d : d ğ•¨.Set orâ€¿o1â€¿o2 ;
    ğ•¨ ğ•Š o1â€¿"LSHIFT"â€¿o2â€¿arrâ€¿d : d ğ•¨.Set lsfâ€¿o1â€¿o2 ;
    ğ•¨ ğ•Š o1â€¿"RSHIFT"â€¿o2â€¿arrâ€¿d : d ğ•¨.Set rsfâ€¿o1â€¿o2 ;
    ğ•© ! 0
  }
  ToBits â† {ğ•Š x : 32â€¿1â€¢bit._castâ‹ˆğ•© ; ğ•Šâ¼ x : âŠ‘âŸ¨1,32âŸ©â€¢bit._cast 32â†‘16â†‘ğ•©}
  Eval â† {
    0â€¿a   : 1â€¿1â€¢bit._notâŒ¾ToBits ğ•Š a ;
    1â€¿aâ€¿b : ToBitsâ¼a(1â€¿1â€¢bit._andâ—‹(ToBitsâˆ˜ğ•Š))b ;
    2â€¿aâ€¿b : ToBitsâ¼a(1â€¿1â€¢bit._orâ—‹(ToBitsâˆ˜ğ•Š))b ;
    3â€¿aâ€¿b : Â»âŸbâŒ¾ToBits ğ•Š a ;
    4â€¿aâ€¿b : Â«âŸbâŒ¾ToBits ğ•Š a ;
      ğ•Š a : cached.Has a ? cached.Get a ;
      ğ•Š a : 1=â€¢Type a ? a ;
      ğ•Š a : a cached.Set x â† ğ•Š h.Get a â‹„ x
  }
  h InjectÂ¨data
  b â† Eval "a"
  {
    2=part ?
      cached â†© HashmapËœâŸ¨âŸ©
      (h â†© HashmapËœâŸ¨âŸ©)InjectÂ¨data
      "b" h.Set b
      Eval "a" ;
    b
  }
}
