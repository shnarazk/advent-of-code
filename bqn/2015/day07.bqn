Solve â‡ {envâ€¿part ğ•Š data :
  utilâ€¿âŸ¨hashmapâŸ© â† â€¢ImportÂ¨"/util.bqn"â€¿"/hashmap.bqn"âˆ¾ËœÂ¨<"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  data ((âˆ§Â´âˆŠâŸœ"0123456789")â—¶âŸ¨âŠ¢,util.ParseIntâŸ©Â¨ " "âŠ¸util.Tokenize)Â¨ â†©
  h â† HashmapËœâŸ¨âŸ©
  cached â† HashmapËœâŸ¨âŸ©
  setâ€¿andâ€¿lsfâ€¿notâ€¿orâ€¿rsf â† â†•6
  Inject â† {
    o1â€¿arrâ€¿d             : d h.Set o1 ;
    o1â€¿"AND"â€¿o2â€¿arrâ€¿d    : d h.Set âŸ¨and,o1,o2âŸ© ;
    o1â€¿"LSHIFT"â€¿o2â€¿arrâ€¿d : d h.Set âŸ¨lsf,o1,o2âŸ© ;
        "NOT"â€¿o1â€¿arrâ€¿d   : d h.Set âŸ¨not,o1âŸ© ;
    o1â€¿"OR"â€¿o2â€¿arrâ€¿d     : d h.Set âŸ¨or ,o1,o2âŸ© ;
    o1â€¿"RSHIFT"â€¿o2â€¿arrâ€¿d : d h.Set âŸ¨rsf,o1,o2âŸ© ;
    ğ•© ! 0
  }
  Eval â† {
    1â€¿aâ€¿b : "and " util.Debug 1â†“ğ•© â‹„ (2â‹†16)|(2â‹†16)+âŠ‘1â€¿16â€¢bit._cast a(1â€¿1â€¢bit._andâ—‹(16â€¿1â€¢bit._castâˆ˜â‹ˆâˆ˜ğ•Š))b ;
    2â€¿aâ€¿b : "lft " util.Debug 1â†“ğ•© â‹„ (2â‹†16)|(2â‹†16)+âŠ‘1â€¿16â€¢bit._cast Â»âŸ2 16â€¿1â€¢bit._castâ‹ˆğ•Š a ;
    3â€¿a   : "not " util.Debug 1â†“ğ•© â‹„ (2â‹†16)|(2â‹†16)+âŠ‘1â€¿16â€¢bit._cast 1â€¿1â€¢bit._not 16â€¿1â€¢bit._castâ‹ˆğ•Š a ;
    4â€¿aâ€¿b : "or  " util.Debug 1â†“ğ•© â‹„ (2â‹†16)|(2â‹†16)+âŠ‘1â€¿16â€¢bit._cast a(1â€¿1â€¢bit._orâ—‹(16â€¿1â€¢bit._castâˆ˜â‹ˆâˆ˜ğ•Š))b ;
    5â€¿aâ€¿b : "rft " util.Debug 1â†“ğ•© â‹„ (2â‹†16)|(2â‹†16)+âŠ‘1â€¿16â€¢bit._cast Â«âŸ2 16â€¿1â€¢bit._castâ‹ˆğ•Š a ;
    ğ•Š a : 1=â€¢Type a ? "int" util.Debug a ;
    ğ•Š a : cached.Has a ? cached.Get a ; x â† ğ•Š h.Get "sym" util.Debug ğ•© â‹„ ğ•© cached.Set x â‹„ x
  }
  {
    1=part ?
       InjectÂ¨data
       # EvalÂ¨"f"â€¿"g"â€¿"h"â€¿"i"â€¿"d"â€¿"e"
       Eval "a"
       cached.Valuesâ¼Ëœ@
      ;
    0
  }
}
