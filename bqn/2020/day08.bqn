Solve â‡ {envâ€¿part ğ•Š data :
  util â† â€¢Import "/util.bqn"âˆ¾Ëœ"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  data (util.ParseIntâŒ¾(1âŠ¸âŠ‘)" "âŠ¸util.Tokenize)Â¨ â†©
  {
    1=part ?
      âŠ‘{ğ•Š accâ€¿pcâ€¿counts :
        counts (1âŠ¸+)âŒ¾(pcâŠ¸âŠ‘) â†©
        {
          2=pcâŠ‘counts ? âŸ¨acc,pc,countsâŸ© ;
          {
            "acc"â€¿o : pcâ€¿acc (1â€¿oâŠ¸+) â†© ;
            "jmp"â€¿o : pc       (oâŠ¸+) â†© ;
            "nop"â€¿o : pc       (1âŠ¸+) â†©
          }pcâŠ‘data
        }
        âŸ¨acc,pc,countsâŸ©
      }â€¢_while_(2>(âŒˆÂ´2âŠ¸âŠ‘))âŸ¨0,0,dataâ‰ âŠ¸â†‘0âŸ© ;
    variations â† ("acc"â‰¢âŠ‘)Â¨âŠ¸/âŸœ(â†•â‰ )data
    ops â† â‰ data
    Flip â† {{"jmp"â‰¡ğ•©}â—¶âŸ¨"jmp","nop"âŸ©âŒ¾(âŠ‘(ğ•©âŠ‘variations)âŠ¸âŠ‘)ğ•¨}
    Executor â† {ğ•Š instructions :
      {accâ€¿pcâ€¿o : âŸ¨opsâ‰ pc,accâŸ©}{ğ•Š accâ€¿pcâ€¿counts :
        counts (1âŠ¸+)âŒ¾(pcâŠ¸âŠ‘) â†©
        {
          2=pcâŠ‘counts ? âŸ¨acc,pc,countsâŸ© ;
          {
            "acc"â€¿o : pcâ€¿acc (1â€¿oâŠ¸+) â†© ;
            "jmp"â€¿o : pc       (oâŠ¸+) â†© ;
            "nop"â€¿o : pc       (1âŠ¸+) â†©
          }pcâŠ‘instructions
        }
        âŸ¨acc,pc,countsâŸ©
      }â€¢_while_{accâ€¿pcâ€¿counts : (0â‰¤pc)âˆ§(ops>pc)âˆ§2>âŒˆÂ´counts}âŸ¨0,0,opsâ†‘0âŸ©
    }
    1âŠ‘{ğ•Š notfoundâ€¿n : {Â¬âŠ‘res â† Executor data Flip n ? res ; âŸ¨1,1+nâŸ©}}â€¢_while_âŠ‘1â€¿0
  }
}
