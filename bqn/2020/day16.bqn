Solve â‡ {envâ€¿part ğ•Š data :
  utilâ€¿âŸ¨hashmapâŸ© â† â€¢ImportÂ¨ "/util.bqn"â€¿"/hashmap.bqn"âˆ¾ËœÂ¨<"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  data â†© ((Â¬Ã—+`)âŸ¨âŸ©âŠ¸â‰¡Â¨)âŠ¸âŠ”data
  ranges â† {<Ë˜2â€¿2â¥Šutil.ParseIntÂ¨" or-" util.Split 1âŠ‘":"util.Split ğ•©}Â¨(âŸ¨âŸ©âŠ¸â‰¢)Â¨âŠ¸/âŠ‘data
  cands â† (âŸ¨âŸ©âŠ¸â‰¢)Â¨âŠ¸/util.ParseIntsÂ¨2âŠ‘data
  mine â† util.ParseInts 1âŠ‘1âŠ‘data
  MakeMask â† âŠ£+â†•âˆ˜(Â¬Ëœ)
  maskZ â† 0â†‘Ëœ1+ (âŒˆÂ´âˆ¾âˆ¾ranges) âŒˆ âŒˆÂ´âˆ¾cands
  mask â† maskZ {r1â€¿r2 ğ•Š m: 1Â¨âŒ¾((MakeMaskÂ´r2)âŠ¸âŠ)1Â¨âŒ¾((MakeMaskÂ´r1)âŠ¸âŠ)m}Â´ ranges
  {
    1=part ?
      +Â´{âŸ¨âŸ©âŠ¸â‰¡â—¶âŸ¨âŠ‘,0âŸ©Â·âˆ¾(âŠ‘âŸœmask)â—¶âŸ¨â‹ˆâŠ¢,âŸ¨âŸ©âŸ©Â¨}Â¨cands
    ;
      specs â† {(âŠ£â‹ˆ(util.ParseIntÂ¨" or-"âŠ¸util.Split))Â´":"util.Split ğ•©}Â¨(âŸ¨âŸ©âŠ¸â‰¢)Â¨âŠ¸/âŠ‘data
      fields â† â‰>valids â† âŸ¨mineâŸ©âˆ¾(âˆ§Â´âˆ˜âŠâŸœmask)Â¨âŠ¸/cands
      Determine â† {
        âŸ¨âŸ©    ğ•Š  âŸ¨âŸ©   : @ ;
        specs ğ•Š fields:
          Cands â† {ğ•Š nameâ€¿range:
             r1bâ€¿r1eâ€¿r2bâ€¿r2e â† range
             mask â† 1Â¨âŒ¾((r2b MakeMask r2e)âŠ¸âŠ)1Â¨âŒ¾((r1b MakeMask r1e)âŠ¸âŠ)maskZ
             {âˆ§Â´ğ•©âŠmask}Ë˜fields
          }
          m â† >CandsÂ¨specs
          map â† HashmapËœâŸ¨âŸ©
          D â† { ğ•Š m:
            uni â† (1=+Â´âˆ˜âŠâŸœm)Â¨âŠ¸/â†•â‰ m
            âŸ¨âŸ©â‰¢uni ?
              {j â† <â¼(ğ•©âŠm)âŠ1 â‹„ ğ•© map.Set j â‹„ m â†© (0Â¨âŒ¾(jâŠ¸âŠ))âŒ¾â‰m}Â¨uni
              D m
            ; @
          }
          D m
          map
      }
      map â† specs Determine fields
      targets â† map.GetÂ¨("departure"â‰¡(9âŠ¸â†‘âˆ˜âŠ‘âŠ‘âŸœspecs))Â¨âŠ¸/â†•â‰ specs
      Ã—Â´targetsâŠmine
  }
}
