Solve â‡ {envâ€¿part ğ•Š data :
  utilâ€¿âŸ¨hashsetâŸ© â† â€¢ImportÂ¨"/util.bqn"â€¿"/hashset.bqn"âˆ¾ËœÂ¨<"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  shape â†â‰¢data (>'#'âŠ¸=) â†©
  map â† Hashset 0âŠ¸âˆ¾Â¨(âŠ‘âŸœdata)Â¨âŠ¸/â¥Šâ†•shape
  # "init map" util.Debug map.Valuesâ¼@
  kernel â† âŸ¨0,0,0âŸ©âŠ¸â‰¢Â¨âŠ¸/âˆ§â¥Š(âŠ¢âˆ¾âŒœ(â‹ˆâŒœËœ))Â¯1+â†•3
  Neighbors â† kernel+<
  {
    1=part ?
      Next â† {ğ•Š map :
        next â† HashsetâŸ¨âŸ©
        "# lives" util.Debug lives â† Â¯1â€¿1+(âŒŠÂ´â‹ˆâŒˆÂ´) map.Valuesâ¼Ëœ@
        "# targets" util.Debug targets â† âˆ§â¥Š(<âŠ‘lives)+â†•Â¬ËœÂ´lives
        Around â† +Â´(map.HasÂ¨)âˆ˜Neighbors
        Alive â† map.Hasâ—¶âŸ¨3=Around,âˆŠâŸœ2â€¿3âŒ¾â‹ˆ AroundâŸ©
        # Check â† Around
        # "check" util.Debug CheckÂ¨targets
        next.SetÂ¨ AliveÂ¨âŠ¸/targets
        # (map.Count@) util.Debug next.Count@
        next
      }
      final â† NextâŸ6 map
      final.Count@
    ;
      0
  }
}
