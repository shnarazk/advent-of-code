Solve â‡ {envâ€¿part ğ•Š data :
  lib â† "." env.VarâŒ¾â‹ˆ "BQN_LIB"
  utilâ€¿âŸ¨HashMapâŸ©â€¿âŸ¨HashSetâŸ© â† â€¢ImportÂ¨"/util.bqn"â€¿"/hashmap.bqn"â€¿"/hashset.bqn"âˆ¾ËœÂ¨<lib
  "â‰¢" util.Debug â‰¢data â†© âŸ¨â‰ data,âˆ˜âŸ©â¥Šâˆ¾data
  start_positionâ€¿end_position â† 0â€¿Â¯1âŠ nowinds â† ('.'âŠ¸â‰¡dataâŠ¸(âŠ‘Ëœ))Â¨âŠ¸/â¥Šâ†•â‰¢data 
  bnesw â† {(ğ•©âŠ¸â‰¡dataâŠ¸(âŠ‘Ëœ))Â¨â†•â‰¢data}Â¨ "#^>v<"    # Blockâ€¿Northâ€¿Eastâ€¿Southâ€¿West
  # FIXME: winds can't be on wall; their cycles are n-2
  Scene â† {>âŒˆË âŸ¨0â€¿0,Â¯1â€¿0,0â€¿1,1â€¿0,0â€¿Â¯1âŸ©(-ğ•©Ã—âŠ£)âŠ¸{yâ€¿xğ•Šm : yâŒ½â‰2 xâŒ½â‰1 m}Â¨bnesw}
  Shift â† {(0<ğ•¨)â—¶âŸ¨Â»,Â«âŸ©âŸ(|ğ•¨)ğ•©}
  Adjacent â† {ğ•Š m : >âŒˆË{ğ•Š yâ€¿x : y Shiftâ‰2 x Shiftâ‰1 m}Â¨âŸ¨0â€¿0,Â¯1â€¿0,0â€¿1,1â€¿0,0â€¿Â¯1âŸ©}
  Return â† {âŠ‘ğ•©}
  "startâ€¿end" util.Debug startâ€¿end â† {ğ•©âŠ¸â‰¡Â¨â†•â‰¢data}Â¨ start_positionâ€¿end_position
  # "Adjacent" util.Debug Adjacent start
  WidthFirstSearch â† {round ğ•Š states:
    "overflow"!round<10
    (â€¢Fmt round) util.Debug states â†© states AdjacentâŠ¸{ğ•¨âˆ§Â¬ğ•©}âŸœScene round 
    âŸ¨1+round,statesâŸ©
  }
  Return WidthFirstSearchÂ´â€¢_while_(Â¬Â·end_positionâŠ¸âŠ‘1âŠ¸âŠ‘)1â€¿start
}
