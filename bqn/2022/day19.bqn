libâ€¿âŸ¨_to_heapâŸ© â† â€¢ImportÂ¨ "../lib.bqn"â€¿"../heap.bqn"
oreâ€¿clayâ€¿obsidianâ€¿geode â† â†•4

Solve â‡ { part ğ•Š line:
  "â‰¢data" lib.Debug â‰¢data â† >{
    is â† lib.ParseInts ğ•©
    4â€¿4â¥ŠâŸ¨
          1âŠ‘is,    0,    0,   0,
          2âŠ‘is,    0,    0,   0,
          3âŠ‘is, 4âŠ‘is,    0,   0,
          5âŠ‘is,    0, 6âŠ‘is,   0,
        âŸ©
  }Â¨ line
  {
    0=part ?
      state1 â† state â† 1â€¿0â€¿âŸ¨5,14,3,0âŸ©â€¿âŸ¨1,1,0,1âŸ©
      "blueprint" lib.Debug blueprint â† âŠdata
      "state" lib.Debug state
      "producible" lib.Debug {(ğ•©âŠblueprint) (âˆ§Â´â‰¤) 2âŠ‘state}Â¨â†•4
      0
    ; 1=part ?
        limit â† 24
        Examine â† { ğ•Š n:
          max_so_far â† 0
          bp â† nâŠdata
          robot_limits â† 3â†‘âŒˆÂ´Ë˜â‰bp
          state â† âŸ¨0âŸ©âˆ¾âŸ¨0,0,0,0âŸ©âˆ¾âŸ¨1,0,0,0âŸ© # âŸ¨time,resources,robotsâŸ©
          to_visit â† âŸ¨stateâŸ©
          Expand â† { ğ•Š to_visit:
            new_states â† âŸ¨âŸ©
            { ğ•Š state:
              time â† -âŠ‘state
              resources â† 4â†‘1â†“state
              robots â† 5â†“state
              max_so_far (geodeâŠ‘resources+(limit-time)Ã—robots)âŠ¸âŒˆ â†©
              { ğ•Š robot:
                mask â† 0< required â† robotâŠbp
                { âˆ§Â´mask/0<robots ?
                    reqâ€¿resâ€¿rob â† (maskâŠ¸/)Â¨requiredâ€¿resourcesâ€¿robots
                    t â† time+ wait â† 1+âŒˆâŒˆÂ´robÃ·Ëœreq(0âŠ¸âŒˆ-)res
                    { t < limit ?
                        generated â† required-Ëœresources+waitÃ—robots
                        robots_   â† (1âŠ¸+)âŒ¾(robotâŠ¸âŠ‘)robots
                        new_state â† (-t)âˆ¾generatedâˆ¾robots_
                        # { 0<â‰ new_states ?
                        #     "state" lib.Debug new_state
                        #     "stack" lib.Debug new_states
                        #     lib.DebugÂ¨ new_states
                        #     "check" lib.Debug ({ğ•Š tâ€¿sâ€¿b: tâˆ§(âˆ§Â´s)âˆ§(âˆ§Â´b)}new_stateâŠ¸â‰¤)Â¨new_states
                        #   ; @
                        # }
                        { (âˆ¨Â´(âˆ§Â´new_stateâŠ¸â‰¤)Â¨new_states)âˆ¨(âˆ¨Â´robot_limits<3â†‘robots_) ? @
                          ;
                            new_states âŸ¨new_stateâŸ©âŠ¸âˆ¾ â†©
                        }
                      ;@
                    }
                  ;@
                }
              }Â¨â†•4
            }Â¨to_visit
            new_states
          }
          lib.While { ğ•¤, 0<â‰ to_visit }â€¿{ ğ•¤, to_visit Expand â†© }
          "=" lib.Debug (n+1)Ã—max_so_far
        }
        +Â´ExamineÂ¨â†•â‰ data
    ; 2=part ?
        limit â† 32
        Examine â† { ğ•Š n:
          max_so_far â† 0
          bp â† nâŠdata
          robot_limits â† 3â†‘âŒˆÂ´Ë˜â‰bp
          state â† âŸ¨0âŸ©âˆ¾âŸ¨0,0,0,0âŸ©âˆ¾âŸ¨1,0,0,0âŸ© # âŸ¨time,resources,robotsâŸ©
          to_visit â† âŸ¨stateâŸ©
          Expand â† { ğ•Š to_visit:
            new_states â† âŸ¨âŸ©
            { ğ•Š state:
              time â† -âŠ‘state
              resources â† 4â†‘1â†“state
              robots â† 5â†“state
              max_so_far (geodeâŠ‘resources+(limit-time)Ã—robots)âŠ¸âŒˆ â†©
              { ğ•Š robot:
                mask â† 0< required â† robotâŠbp
                { âˆ§Â´mask/0<robots ?
                    reqâ€¿resâ€¿rob â† (maskâŠ¸/)Â¨requiredâ€¿resourcesâ€¿robots
                    t â† time+ wait â† 1+âŒˆâŒˆÂ´robÃ·Ëœreq(0âŠ¸âŒˆ-)res
                    { t < limit ?
                        generated â† required-Ëœresources+waitÃ—robots
                        robots_   â† (1âŠ¸+)âŒ¾(robotâŠ¸âŠ‘)robots
                        new_state â† (-t)âˆ¾generatedâˆ¾robots_
                        # { 0<â‰ new_states ?
                        #     "state" lib.Debug new_state
                        #     "stack" lib.Debug new_states
                        #     lib.DebugÂ¨ new_states
                        #     "check" lib.Debug ({ğ•Š tâ€¿sâ€¿b: tâˆ§(âˆ§Â´s)âˆ§(âˆ§Â´b)}new_stateâŠ¸â‰¤)Â¨new_states
                        #   ; @
                        # }
                        { (âˆ¨Â´(âˆ§Â´new_stateâŠ¸â‰¤)Â¨new_states)âˆ¨(âˆ¨Â´robot_limits<3â†‘robots_) ? @
                          ;
                            new_states âŸ¨new_stateâŸ©âŠ¸âˆ¾ â†©
                        }
                      ;@
                    }
                  ;@
                }
              }Â¨â†•4
            }Â¨to_visit
            new_states
          }
          lib.While { ğ•¤, 0<â‰ to_visit }â€¿{ ğ•¤, to_visit Expand â†© }
          "=" lib.Debug max_so_far
        }
        Ã—Â´ExamineÂ¨â†•3
    ;
        âŸ¨âŸ©
  }
}
