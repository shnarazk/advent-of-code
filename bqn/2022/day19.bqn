libâ€¿âŸ¨_to_heapâŸ© â† â€¢ImportÂ¨ "../lib.bqn"â€¿"../heap.bqn"
oreâ€¿clayâ€¿obsidianâ€¿geode â† â†•4

# returns the goodness
Value â† { blueprint ğ•Š Â·â€¿Â·â€¿resourcesâ€¿robots: 0 {ğ•¨+2Ã—ğ•©}Â´ robots }
Producible â† âˆ§Â´{ (0=ğ•¨)âˆ¨(0<ğ•©) }Â¨
RequiredResources â† (0âŠ¸âŒˆ-)
# FIXME: this is incorrect: count the number of robots
RequiredTime â† âŒˆÂ´âˆ˜(0âŠ¸âŒˆ-)

Solve â‡ { part ğ•Š line:
  "â‰¢data" lib.Debug â‰¢data â† >{
    is â† lib.ParseInts ğ•©
    4â€¿4â¥ŠâŸ¨
          1âŠ‘is,    0,    0,   0,
          2âŠ‘is,    0,    0,   0,
          3âŠ‘is, 4âŠ‘is,    0,   0,
          5âŠ‘is,    0, 6âŠ‘is,   0,
        âŸ©
  }Â¨ line
  # To_visit â† (>â—‹(1âŠ¸âŠ‘))_to_heap
  # To_visit â† (>â—‹(Â¯1âŠ¸âŠ‘))_to_heap
  # to_visit.Push "state" lib.Debug <state â† 1â€¿0â€¿âŸ¨1,0,0,0âŸ©â€¿âŸ¨1,0,0,0âŸ©  # heap of âŸ¨power,time,resources,robotsâŸ©
  # visited â† âŸ¨stateâŸ©
  {
    0=part ?
      state1 â† state â† 1â€¿0â€¿âŸ¨5,14,3,0âŸ©â€¿âŸ¨1,1,0,1âŸ©
      "blueprint" lib.Debug blueprint â† âŠdata
      "state" lib.Debug state
      "producible" lib.Debug {(ğ•©âŠblueprint) (âˆ§Â´â‰¤) 2âŠ‘state}Â¨â†•4
      0
      ;
    1=part ?
        limit â† 24
        Examine â† { ğ•Š n:
          max_so_far â† 0
          bp â† nâŠdata
          To_visit â† (>â—‹âŠ‘)_to_heap
          to_visit.Push < state â† 0â€¿âŸ¨0,0,0,0âŸ©â€¿âŸ¨1,0,0,0âŸ© # heap of âŸ¨time,resources,robotsâŸ©
          visited â† âŸ¨stateâŸ©
          Expand â† { ğ•Š timeâ€¿resourcesâ€¿robots:
            max_so_far (Â¯1âŠ‘resources+(limit-time)Ã—robots)âŠ¸âŒˆ â†©
            { ğ•Š robot:
              mask â† 0< required â† robotâŠbp
              { âˆ§Â´mask/0<robots ?
                  reqâ€¿resâ€¿rob â† (maskâŠ¸/)Â¨requiredâ€¿resourcesâ€¿robots
                  wait â† 1+âŒˆâŒˆÂ´robÃ·Ëœreq(0âŠ¸âŒˆ-)res
                  t â† time+wait
                  { t < limit ?
                      generated â† required-Ëœresources+waitÃ—robots
                      robots_ â† (1âŠ¸+)âŒ¾(robotâŠ¸âŠ‘)robots
                      âŸ¨âŸ© lib.Debug new_state â† tâ€¿generatedâ€¿robots_
                      to_visit.Push < new_state
                      # { (time<9)âˆ§(1=robot)âˆ§(1â‰¤1âŠ‘robots) ?
                      #     # "reqâ€¿resâ€¿rob" lib.Debug reqâ€¿resâ€¿rob
                      #     "new_state" lib.Debug new_state
                      #   ; @
                      # }
                      # { âˆ¨Â´{ ğ•Š tiâ€¿rsâ€¿rb: (tiâ‰¤t)âˆ§(rs(âˆ§Â´â‰¤)generated)âˆ§(robots_(âˆ§Â´â‰¤)rb) }Â¨visited? @
                      #   ;
                      #     to_visit.Push < new_state
                      #     # visited âŸ¨new_stateâŸ©âŠ¸âˆ¾ â†©
                      #     # lib.Debug â‰ visited
                      # }
                    ;
                      max_so_far (Â¯1âŠ‘resources+(limit-time)Ã—robots)âŠ¸âŒˆ â†©
                  }
                ;@
              }
            }Â¨ â†•4
          }
          lib.While { ğ•¤, Â¬to_visit.Empty @ }â€¿{ ğ•¤, state â† to_visit.Pop @, Expand state }
          "=" lib.Debug (n+1) Ã— max_so_far
        }
        +Â´ExamineÂ¨â†•â‰ data
    ;
        âŸ¨âŸ©
  }
}
