lib â† â€¢Import "../lib.bqn"

Solve â‡ { part ğ•Š line:
  data â† >{
    is â† lib.ParseInts ğ•©
    4â€¿4â¥ŠâŸ¨
          1âŠ‘is,    0,    0,   0,
          2âŠ‘is,    0,    0,   0,
          3âŠ‘is, 4âŠ‘is,    0,   0,
          5âŠ‘is,    0, 6âŠ‘is,   0,
        âŸ©
  }Â¨ line
  Examine â† { limit ğ•Š n:
    max_so_far   â† 0
    bp           â† nâŠdata
    robot_limits â† 3â†‘âŒˆÂ´Ë˜â‰bp
    Expand â† {
      ğ•Š âŸ¨âŸ©: max_so_far;
      ğ•Š to_visit:
        new_states â† âŸ¨âŸ©
        { ğ•Š state:
          timeâ€¿resourcesâ€¿robots â† âŸ¨-âŠ‘state,4â†‘1â†“state,5â†“stateâŸ©
          max_so_far (Â¯1âŠ‘resources+(limit-time)Ã—robots)âŠ¸âŒˆ â†©
          { ğ•Š robot:
            mask â† 0< required â† robotâŠbp
            { âˆ§Â´mask/0<robots ?
                reqâ€¿resâ€¿rob â† (maskâŠ¸/)Â¨requiredâ€¿resourcesâ€¿robots
                time_ â† time+ wait â† 1+âŒˆâŒˆÂ´robÃ·Ëœreq(0âŠ¸âŒˆ-)res
                { time_ < limit ?
                    resources_ â† required-Ëœresources+waitÃ—robots
                    robots_    â† (1âŠ¸+)âŒ¾(robotâŠ¸âŠ‘)robots
                    state_     â† (-time_)âˆ¾resources_âˆ¾robots_
                    { (âˆ§Â´robot_limitsâ‰¥3â†‘robots_) ? Â¬âˆ¨Â´(âˆ§Â´state_âŠ¸â‰¤)Â¨new_states ? new_states âŸ¨state_âŸ©âŠ¸âˆ¾ â†© ;@ }
                  ;@
                }
              ;@
            }
          }Â¨â†•4
        }Â¨to_visit
        ğ•Š new_states
    }
    (â€¢Fmt n) lib.Debug Expand âŸ¨âŸ¨0âŸ©âˆ¾âŸ¨0,0,0,0âŸ©âˆ¾âŸ¨1,0,0,0âŸ©âŸ© # âŸ¨time,resources,robotsâŸ©
  }
  {
    0=part   ? "â‰¢data" lib.Debug â‰¢data
    ; 1=part ? +Â´ 24 ((1âŠ¸+)Ã—Examine)Â¨â†•â‰ data
    ; 2=part ? Ã—Â´ 32 ExamineÂ¨â†•3
    ; âŸ¨âŸ©
  }
}
