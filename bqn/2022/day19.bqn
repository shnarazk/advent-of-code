libâ€¿âŸ¨_to_heapâŸ© â† â€¢ImportÂ¨ "../lib.bqn"â€¿"../heap.bqn"
oreâ€¿clayâ€¿obsidianâ€¿geode â† â†•4

# returns the goodness
Value â† { blueprint ğ•Š Â·â€¿Â·â€¿resourcesâ€¿robots: 0 {ğ•¨+2Ã—ğ•©}Â´ robots }

Solve â‡ { part ğ•Š line:
  "â‰¢data" lib.Debug â‰¢data â† >{
    is â† lib.ParseInts ğ•©
    4â€¿4â¥ŠâŸ¨
          1âŠ‘is,    0,    0,   0,
          2âŠ‘is,    0,    0,   0,
          3âŠ‘is, 4âŠ‘is,    0,   0,
          5âŠ‘is,    0, 6âŠ‘is,   0,
        âŸ©
  }Â¨ line
  To_visit â† (>â—‹(Â¯1âŠ¸âŠ‘))_to_heap
  to_visit.Push<state â† 1â€¿0â€¿âŸ¨1,0,0,0âŸ©â€¿âŸ¨1,0,0,0âŸ©  # heap of âŸ¨power,time,resources,robotsâŸ©
  visited â† âŸ¨stateâŸ©
  {
    0=part ?
      state1 â† state â† 1â€¿0â€¿âŸ¨5,14,3,0âŸ©â€¿âŸ¨1,1,0,1âŸ©
      "blueprint" lib.Debug blueprint â† âŠdata
      "state" lib.Debug state
      "producible" lib.Debug {(ğ•©âŠblueprint) (âˆ§Â´â‰¤) 2âŠ‘state}Â¨â†•4
      0
      ;
    1=part ?
        max_so_far â† 0
        Expand â† { bp ğ•Š powerâ€¿timeâ€¿resourcesâ€¿robots:
          geodes â† 0
          { max_so_far<geodes  ? max_so_far â†© geodes ; @ }
          { ğ•Š robot:
            "required" lib.Debug required â† robotâŠbp
            "resources" lib.Debug resources
            { required (âˆ§Â´â‰¤) resources ?
                 lib.Debug "passed"
                 new_state â† state
                 to_visit.Push < new_state
              ;@
            }
          }Â¨ â†•3
        }
        "bp" lib.Debug bp â† âŠdata
        lib.While { ğ•¤, Â¬to_visit.Empty @ }â€¿{ ğ•¤, state â† to_visit.Pop @, bp Expand state }
        "_visited" lib.Debug visited
        âŸ¨âŸ©
    ;
        âŸ¨âŸ©
  }
}
