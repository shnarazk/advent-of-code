libâ€¿âŸ¨_to_heapâŸ© â† â€¢ImportÂ¨ "../lib.bqn"â€¿"../heap.bqn"
oreâ€¿clayâ€¿obsidianâ€¿geode â† â†•4

# returns the goodness (mining ability)
Value â† { blueprint ğ•Š Â·â€¿Â·â€¿resourcesâ€¿robots:
  k0â€¿k1â€¿k2â€¿k3 â† âŠ‘âŸœblueprint(âˆ¾âŸœ0)Â¨â†•4
  k2 (k1Ã—2â€¿1âŠ‘blueprint)âŠ¸+ â†©
  k3 (k2Ã—3â€¿2âŠ‘blueprint)âŠ¸+ â†©
  (geodeâŠ‘resources)++Â´k0â€¿k1â€¿k2â€¿k3Ã—robots
}

Solve â‡ { part ğ•Š line:
  "â‰¢data" lib.Debug â‰¢data â† >{
    is â† lib.ParseInts ğ•©
    4â€¿4â¥ŠâŸ¨0,    0,    0, 1âŠ‘is,
         0,    0,    0, 2âŠ‘is,
         0,    0, 3âŠ‘is, 4âŠ‘is,
         0, 5âŠ‘is,    0, 6âŠ‘isâŸ©
  }Â¨ line
  "data[0â€¿0]" lib.Debug 0âŠ0âŠdata
  {
    1=part ?
        To_visit â† (>â—‹(Â¯1âŠ¸âŠ‘))_to_heap
        to_visit.Push<state â† 1â€¿0â€¿âŸ¨0,0,0,1âŸ©â€¿âŸ¨0,0,0,1âŸ©  # heap of âŸ¨power,time,resources,robotsâŸ©
        visited â† âŸ¨stateâŸ©
        max_so_far â† 0
        Expand â† { bp ğ•Š powerâ€¿timeâ€¿resourcesâ€¿robots:
          geodes â† 0
          { max_so_far<geodes ? max_so_far â†© geodes ; @ }
          {ğ•Š robot:
            required â† robotâŠbp
            { required âˆ§Â´< resources ?
                 new_state â† state
                 to_visit.Push < new_state
              ;@
            }
          } â†•3
        }
        bp â† âŠ‘data
        lib.While { ğ•¤, Â¬to_visit.Empty @ }â€¿{ ğ•¤, state â† to_visit.Pop @, bp Expand state }
        âŸ¨âŸ©
    ;
        âŸ¨âŸ©
  }
}
