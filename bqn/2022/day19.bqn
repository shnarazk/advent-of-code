lib â† â€¢Import "../lib.bqn"

Solve â‡ { part ğ•Š line:
  data â† >{
    is â† lib.ParseInts ğ•©
    4â€¿4â¥ŠâŸ¨
          1âŠ‘is,    0,    0,   0,
          2âŠ‘is,    0,    0,   0,
          3âŠ‘is, 4âŠ‘is,    0,   0,
          5âŠ‘is,    0, 6âŠ‘is,   0,
        âŸ©
  }Â¨ line
  Examine â† { u ğ•Š n:
    bestâ€¿bpâ€¿upto â† âŸ¨0,nâŠdata,-uâŸ©
    masksâ€¿limits â† âŸ¨0<Ë˜bp,0â€¿0â€¿0â€¿âˆâŒˆâŒˆÂ´Ë˜â‰bpâŸ©
    Expand â† {
      ğ•Š âŸ¨âŸ©: best;
      ğ•Š to_visit:
        next â† âŸ¨âŸ©
        { ğ•Š state:
          timeâ€¿resourcesâ€¿robots â† âŸ¨âŠ‘state,4â†‘1â†“state,5â†“stateâŸ©
          best (Â¯1âŠ‘resources+(time-upto)Ã—robots)âŠ¸âŒˆ â†©
          { ğ•Š i:        # FIXME: this is not an array oriented approach.
            { robotsâ‰¤â—‹(iâŠ¸âŠ‘)limits ?
                need â† iâŠbp
                masked â† (iâŠmasks)/robotsÃ·Ëœneed(0âŠ¸âŒˆ-)resources
                { upto< ti â† time- wait â† 1+âŒˆâŒˆÂ´masked ?
                    s â† tiâˆ¾(need-Ëœresources+waitÃ—robots)âˆ¾((1âŠ¸+)âŒ¾(iâŠ¸âŠ‘)robots)
                    { Â¬âˆ¨Â´(âˆ§Â´sâŠ¸â‰¤)Â¨next ? next âŸ¨sâŸ©âŠ¸âˆ¾ â†© ;@ }
                  ;@
                }
                ;@
              }
            }Â¨â†•4
        }Â¨to_visit
        ğ•Š next
    }
    (â€¢Fmt n) lib.Debug Expand âŸ¨âŸ¨0âŸ©âˆ¾âŸ¨0,0,0,0âŸ©âˆ¾âŸ¨1,0,0,0âŸ©âŸ© # âŸ¨time,resources,robotsâŸ©
  }
  {
    0=part   ? "â‰¢data" lib.Debug â‰¢data
    ; 1=part ? +Â´ 24 ((1âŠ¸+)Ã—Examine)Â¨â†•â‰ data
    ; 2=part ? Ã—Â´ 32 ExamineÂ¨â†•3
    ; âŸ¨âŸ©
  }
}
