lib â† â€¢Import "../lib.bqn"

Solve â‡ { part ğ•Š line:
  data â† >{
    is â† lib.ParseInts ğ•©
    4â€¿4â¥ŠâŸ¨
          1âŠ‘is,    0,    0,   0,
          2âŠ‘is,    0,    0,   0,
          3âŠ‘is, 4âŠ‘is,    0,   0,
          5âŠ‘is,    0, 6âŠ‘is,   0,
        âŸ©
  }Â¨ line
  Examine â† { limit ğ•Š n:
    max_so_far â† 0
    bp         â† nâŠdata
    masks      â† 0<Ë˜ bp
    limits     â† 0â€¿0â€¿0â€¿âˆâŒˆâŒˆÂ´Ë˜â‰bp
    Expand â† {
      ğ•Š âŸ¨âŸ©: max_so_far;
      ğ•Š to_visit:
        next â† âŸ¨âŸ©
        { ğ•Š state:
          timeâ€¿resourcesâ€¿robots â† âŸ¨-âŠ‘state,4â†‘1â†“state,5â†“stateâŸ©
          max_so_far (Â¯1âŠ‘resources+(limit-time)Ã—robots)âŠ¸âŒˆ â†©
          # FIXME: this is not an array oriented approach.
          { ğ•Š i:
            mask â† iâŠmasks
            { âˆ§Â´0<mask/robots ?
                need â† iâŠbp
                ti   â† time+ wait â† 1+âŒˆâŒˆÂ´(maskâŠ¸/)robotsÃ·Ëœneed(0âŠ¸âŒˆ-)resources
                { ti < limit ?
                    res â† need-Ëœresources+waitÃ—robots
                    rob â† (1âŠ¸+)âŒ¾(iâŠ¸âŠ‘)robots
                    s   â† (-ti)âˆ¾resâˆ¾rob
                    { (âˆ§Â´robâ‰¤limits) ? Â¬âˆ¨Â´(âˆ§Â´sâŠ¸â‰¤)Â¨next ? next âŸ¨sâŸ©âŠ¸âˆ¾ â†© ;@ }
                  ;@
                }
              ;@
            }
          }Â¨â†•4
        }Â¨to_visit
        ğ•Š next
    }
    (â€¢Fmt n) lib.Debug Expand âŸ¨âŸ¨0âŸ©âˆ¾âŸ¨0,0,0,0âŸ©âˆ¾âŸ¨1,0,0,0âŸ©âŸ© # âŸ¨time,resources,robotsâŸ©
  }
  {
    0=part   ? "â‰¢data" lib.Debug â‰¢data
    ; 1=part ? +Â´ 24 ((1âŠ¸+)Ã—Examine)Â¨â†•â‰ data
    ; 2=part ? Ã—Â´ 32 ExamineÂ¨â†•3
    ; âŸ¨âŸ©
  }
}
