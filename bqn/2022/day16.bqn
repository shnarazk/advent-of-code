#!/usr/bin/env cbqn
âŸ¨DataFile,ParseInts,Swap,WhileâŸ© â† â€¢Import "../lib.bqn"
âŸ¨_to_heapâŸ© â† â€¢Import "../heap.bqn"
data â† âˆ§(Swap ParseIntsâˆ¾{((<1âŠ¸âŠ‘)âˆ¾9âŠ¸â†“)(','âŠ¸â‰ Â¨âŠ¸/)Â¨" "âŠ¸((âŠ¢-ËœÂ¬Ã—Â·+`Â»âŠ¸<)âˆ˜âˆŠËœâŠ”âŠ¢)ğ•©})Â¨ â€¢Flines "data/2022/input-day16.txt" DataFile â€¢args
nodes â† â·âŠ‘Â¨data
! 0=âŠ‘nodesâŠ<"AA"
pairs â† (â‹ˆâ—‹(âŠ‘nodesâŠ’<))Â´Â¨âˆ¾(âŠ(âˆ¾â—‹<)Â¨(2âŠ¸â†“))Â¨data
dist â† (âŒŠËâˆ˜+â‰1â€¿âˆ)âŸ(â‰ nodes)Ëœ {ğ•¨â‰¡ğ•© ? 0; âŠ‘pairsâˆŠËœâ‹ˆâŸ¨ğ•¨,ğ•©âŸ© ? 1; âˆ}âŒœËœâ†•â‰ nodes
To_visit â† (>â—‹(Â¯1âŠ¸âŠ‘))_to_heap
to_visit.Push<âŸ¨(0âŠ¸=)Â¨â†•â‰ nodes,0,0,0âŸ©   # heap of âŸ¨bitmap,position,time,flowâŸ©
visited â† âˆ˜â€¿2â¥ŠâŸ¨âŸ¨(0âŠ¸=)Â¨â†•â‰ nodes,0,0âŸ©,0âŸ© # map  of âŸ¨bitmap,position,timeâŸ©â†’flow
Expand â† {limit ğ•Š âŸ¨states,pos,time,flowâŸ©:
  {ğ•Š âŸ¨p,costâŸ©:
    t â† 1+time+cost
    {(0=cost)âˆ¨(pâŠ‘states)âˆ¨(limitâ‰¤t)âˆ¨(0=1âŠ‘pâŠ‘data) ?@;
      f â† flow + (limit-t)Ã—1âŠ‘pâŠ‘data
      s â† 1Ë™âŒ¾(pâŠ¸âŠ‘)states
      key_index â† âŠ‘(âŠ‘Ë˜visited)âŠâŸ¨key â† âŸ¨s,p,tâŸ©âŸ©
      {key_index<â‰ visited ?@; visited (âˆ¾âŸœ(âˆ˜â€¿2â¥ŠâŸ¨key,0âŸ©))â†©} # ensure the key exists
      {f â‰¤ âŒˆÂ´(({(tâ‰¥2âŠ‘ğ•©)âˆ§(key â‰¡â—‹(2â†‘âŠ‘) ğ•©)}âˆ˜âŠ‘)Â¨)âŠ¸/âŸœ((1âŠ¸âŠ‘)Â¨)â¥Š<Ë˜visited ?@;
        to_visit.Push<âŸ¨s,p,t,fâŸ©
        visited â†© fË™âŒ¾(key_indexâ€¿1âŠ¸âŠ‘) visited
      }
    }
  }Â¨ ((â†•â‰ )â‹ˆÂ¨âŠ¢) posâŠdist
}
Search â† {F limit:
  cand â† 0
  While {ğ•¤â‹„ Â¬to_visit.Empty @}â€¿{ğ•¤â‹„ state â† to_visit.Pop @â‹„ cand â†© candâŒˆÂ¯1âŠ‘stateâ‹„ limit Expand state}
  cand
}
â€¢Show Search 30

Togo â† (>â—‹(Â¯1âŠ¸âŠ‘))_to_heap
togo.Push<âŸ¨(0âŠ¸=)Â¨â†•â‰ nodes,âŸ¨0,0âŸ©,âŸ¨0,0âŸ©,0âŸ©       # âŸ¨bitmap,âŸ¨position1,time1âŸ©,âŸ¨pisition2,time2âŸ©,flowâŸ©
checked â† âˆ˜â€¿2â¥ŠâŸ¨âŸ¨(0âŠ¸=)Â¨â†•â‰ nodes,âŸ¨0,0âŸ©,âŸ¨0,0âŸ©âŸ©,0âŸ© # âŸ¨bitmap,âŸ¨position1,time1âŸ©,âŸ¨pisition2,time2âŸ©âŸ©â†’flow
best â† 0
Expand2 â† {limit ğ•Š âŸ¨states,âŸ¨p1,t1âŸ©,âŸ¨p2,t2âŸ©,flowâŸ©:
  {ğ•Š âŸ¨p,costâŸ©:
    t â† 1+t1+cost
    {(0=cost)âˆ¨(pâŠ‘states)âˆ¨(limitâ‰¤t)âˆ¨(0=1âŠ‘pâŠ‘data) ?@;
      f â† flow+(limit-t)Ã—1âŠ‘pâŠ‘data
      s â† 1Ë™âŒ¾(pâŠ¸âŠ‘)states
      âŸ¨a,bâŸ© â† { t<t2 ? âŸ¨âŸ¨p,tâŸ©,âŸ¨p2,t2âŸ©âŸ©; âŸ¨âŸ¨p2,t2âŸ©,âŸ¨p,tâŸ©âŸ©}
      # calculation for A*
      remains â† âˆ¨(Â¬Â¨s)/(1âŠ‘Â¨data)
      length â† (Â¯1+limit-1âŠ‘a)âŒŠâ‰ remains
      {bestâ‰¥f++Â´(lengthâ†‘remains)Ã—Â¨lengthâ†‘âŒ½â†•(limit-t)?@;
        key_index â† âŠ‘(âŠ‘Ë˜checked)âŠâŸ¨key â† âŸ¨s,a,bâŸ©âŸ©
        {key_index<â‰ checked ?@; checked (âˆ¾âŸœ(âˆ˜â€¿2â¥ŠâŸ¨key,0âŸ©))â†©}
        {f â‰¤ âŒˆÂ´(({(tâ‰¥1âŠ¸âŠ‘1âŠ¸âŠ‘ğ•©)âˆ§(tâ‰¥1âŠ¸âŠ‘2âŠ¸âŠ‘ğ•©)âˆ§(key â‰¡â—‹(âŠ‘) ğ•©)âˆ§(key â‰¡â—‹(âŠ‘1âŠ¸âŠ‘) ğ•©)âˆ§(key â‰¡â—‹(âŠ‘2âŠ¸âŠ‘) ğ•©)}âˆ˜âŠ‘)Â¨)âŠ¸/âŸœ((1âŠ¸âŠ‘)Â¨)â¥Š<Ë˜checked ?@;
          togo.Push<âŸ¨s,a,b,fâŸ©
          checked â†© fË™âŒ¾(key_indexâ€¿1âŠ¸âŠ‘) checked
        }
      }
    }
  } Â¨ ((â†•â‰ )â‹ˆÂ¨âŠ¢) p1âŠdist
}
Search2 â† {F limit:
  While {ğ•¤â‹„ Â¬togo.Empty @}â€¿{ğ•¤â‹„ state â† togo.Pop @â‹„
    {bestâ‰¤3âŠ¸âŠ‘state ? â€¢Show âŸ¨3âŠ¸âŠ‘state,1âŠ¸âŠ‘1âŠ¸âŠ‘stateâŸ©; @}
    best â†© bestâŒˆ3âŠ¸âŠ‘stateâ‹„ limit Expand2 state}
    best
}
â€¢Show Search2 26
