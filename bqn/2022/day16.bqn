âŸ¨color,DataFile,ParseInts,Swap,term,WhileâŸ© â† â€¢Import "../lib.bqn"
âŸ¨_to_heapâŸ© â† â€¢Import "../heap.bqn"

Run â‡ { part ğ•Š rawdata:
  data â† âˆ§(Swap ParseIntsâˆ¾{((<1âŠ¸âŠ‘)âˆ¾9âŠ¸â†“)(','âŠ¸â‰ Â¨âŠ¸/)Â¨" "âŠ¸((âŠ¢-ËœÂ¬Ã—Â·+`Â»âŠ¸<)âˆ˜âˆŠËœâŠ”âŠ¢)ğ•©})Â¨ rawdata
  nodes â† â·âŠ‘Â¨data
  ! 0=âŠ‘nodesâŠ<"AA"
  pairs â† (â‹ˆâ—‹(âŠ‘nodesâŠ’<))Â´Â¨âˆ¾(âŠ(âˆ¾â—‹<)Â¨(2âŠ¸â†“))Â¨data
  dist â† (âŒŠËâˆ˜+â‰1â€¿âˆ)âŸ(â‰ nodes)Ëœ {ğ•¨â‰¡ğ•© ? 0; âŠ‘pairsâˆŠËœâ‹ˆâŸ¨ğ•¨,ğ•©âŸ© ? 1; âˆ}âŒœËœâ†•â‰ nodes
  {
    1=part ?
      To_visit â† (>â—‹(Â¯1âŠ¸âŠ‘))_to_heap
      to_visit.Push<âŸ¨(0âŠ¸=)Â¨â†•â‰ nodes,0,0,0âŸ©   # heap of âŸ¨bitmap,position,time,flowâŸ©
      visited â† âˆ˜â€¿2â¥ŠâŸ¨âŸ¨(0âŠ¸=)Â¨â†•â‰ nodes,0,0âŸ©,0âŸ© # map  of âŸ¨bitmap,position,timeâŸ©â†’flow
      Expand â† { limit ğ•Š âŸ¨states,pos,time,flowâŸ©:
        { ğ•Š âŸ¨p,costâŸ©:
          t â† 1+time+cost
          {(0=cost)âˆ¨(pâŠ‘states)âˆ¨(limitâ‰¤t)âˆ¨(0=1âŠ‘pâŠ‘data) ?@;
            âŸ¨f,sâŸ© â† âŸ¨flow+(limit-t)Ã—1âŠ‘pâŠ‘data,1Ë™âŒ¾(pâŠ¸âŠ‘)statesâŸ©
            key_index â† âŠ‘(âŠ‘Ë˜visited)âŠâŸ¨key â† âŸ¨s,p,tâŸ©âŸ©
            {key_index<â‰ visited ?@; visited (âˆ¾âŸœ(âˆ˜â€¿2â¥ŠâŸ¨key,0âŸ©))â†©} # ensure the key exists
            {fâ‰¤âŒˆÂ´(({(tâ‰¥2âŠ‘ğ•©)âˆ§(keyâ‰¡â—‹(2â†‘âŠ‘)ğ•©)}âˆ˜âŠ‘)Â¨)âŠ¸/âŸœ((1âŠ¸âŠ‘)Â¨)â¥Š<Ë˜visited ?@;
              to_visit.Push<âŸ¨s,p,t,fâŸ©
              visited fË™âŒ¾(key_indexâ€¿1âŠ¸âŠ‘) â†©
            }
          }
        }Â¨(â†•â‰ )âŠ¸(â‹ˆÂ¨) posâŠdist
      }
      Search â† { F limit:
        cand â† 0
        While {ğ•¤â‹„ Â¬to_visit.Empty @}â€¿{ğ•¤â‹„ state â† to_visit.Pop @â‹„ cand â†© candâŒˆÂ¯1âŠ‘stateâ‹„ limit Expand state}
        cand
      }
      Search 30
    ;
      limit â† 26
      Togo â† (>â—‹(Â¯1âŠ¸âŠ‘))_to_heap
      togo.Push<âŸ¨(0âŠ¸=)Â¨â†•â‰ nodes,âŸ¨0,0âŸ©,âŸ¨0,0âŸ©,0âŸ©       # âŸ¨bitmap,âŸ¨position1,time1âŸ©,âŸ¨pisition2,time2âŸ©,flowâŸ©
      checked â† âˆ˜â€¿2â¥ŠâŸ¨âŸ¨(0âŠ¸=)Â¨â†•â‰ nodes,âŸ¨0,0âŸ©,âŸ¨0,0âŸ©âŸ©,0âŸ© # âŸ¨bitmap,âŸ¨position1,time1âŸ©,âŸ¨pisition2,time2âŸ©âŸ©â†’flow
      best â† 0
      Expand2 â† { limit ğ•Š âŸ¨states,âŸ¨p1,t1âŸ©,âŸ¨p2,t2âŸ©,flowâŸ©:
        { ğ•Š âŸ¨p,costâŸ©:
          t â† 1+t1+cost
          {(0=cost)âˆ¨(pâŠ‘states)âˆ¨(limitâ‰¤t)âˆ¨(0=1âŠ‘pâŠ‘data) ? @;
            âŸ¨f,sâŸ© â† âŸ¨flow+(limit-t)Ã—1âŠ‘pâŠ‘data,1Ë™âŒ¾(pâŠ¸âŠ‘)statesâŸ©
            âŸ¨a,bâŸ© â† {t<t2 ? âŸ¨âŸ¨p,tâŸ©,âŸ¨p2,t2âŸ©âŸ©; âŸ¨âŸ¨p2,t2âŸ©,âŸ¨p,tâŸ©âŸ©}
            length â† (Â¯1+limit-1âŠ‘a)âŒŠâ‰ remains â† âˆ¨(Â¬Â¨s)/(1âŠ‘Â¨data) # A* calculation
            {bestâ‰¥f++Â´remains(Ã—Â¨â—‹(lengthâŠ¸â†‘))âŒ½â†•(limit-t) ? @;
              key_index â† âŠ‘(âŠ‘Ë˜checked)âŠâŸ¨key â† âŸ¨s,a,bâŸ©âŸ©
              {key_index<â‰ checked ?@; checked (âˆ¾âŸœ(âˆ˜â€¿2â¥ŠâŸ¨key,0âŸ©))â†©}
              {fâ‰¤âŒˆÂ´(({(tâ‰¥1âŠ¸âŠ‘1âŠ¸âŠ‘ğ•©)âˆ§(tâ‰¥1âŠ¸âŠ‘2âŠ¸âŠ‘ğ•©)âˆ§(key â‰¡â—‹(âŠ‘)ğ•©)âˆ§(keyâ‰¡â—‹(âŠ‘1âŠ¸âŠ‘)ğ•©)âˆ§(keyâ‰¡â—‹(âŠ‘2âŠ¸âŠ‘)ğ•©)}âˆ˜âŠ‘)Â¨)âŠ¸/âŸœ((1âŠ¸âŠ‘)Â¨)â¥Š<Ë˜checked ? @;
                togo.Push<âŸ¨s,a,b,fâŸ©
                checked fË™âŒ¾(key_indexâ€¿1âŠ¸âŠ‘) â†©
              }
            }
          }
        }Â¨(â†•â‰ )âŠ¸(â‹ˆÂ¨) p1âŠdist
      }
      While {ğ•¤â‹„ Â¬togo.Empty @}â€¿{ğ•¤â‹„ state â† togo.Pop @â‹„
        {bestâ‰¤3âŠ¸âŠ‘state ? (term.clearâˆ¾color.green) term.Print âŸ¨3âŠ¸âŠ‘state,1âŠ¸âŠ‘1âŠ¸âŠ‘stateâŸ©; @}
        best â†© bestâŒˆ3âŠ¸âŠ‘stateâ‹„ limit Expand2 state
      }
      best
  }
}
