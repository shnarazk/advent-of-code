#!/usr/bin/env cbqn
âŸ¨DataFile,ParseInts,Swap,WhileâŸ© â† â€¢Import "../lib.bqn"
âŸ¨_to_heapâŸ© â† â€¢Import "../heap.bqn"
data â† âˆ§(Swap ParseIntsâˆ¾{((<1âŠ¸âŠ‘)âˆ¾9âŠ¸â†“)(','âŠ¸â‰ Â¨âŠ¸/)Â¨" "âŠ¸((âŠ¢-ËœÂ¬Ã—Â·+`Â»âŠ¸<)âˆ˜âˆŠËœâŠ”âŠ¢)ğ•©})Â¨ â€¢Flines "data/2022/input-day16.txt" DataFile â€¢args
nodes â† â·âŠ‘Â¨data
! 0=âŠ‘nodesâŠ<"AA"
pairs â† (â‹ˆâ—‹(âŠ‘nodesâŠ’<))Â´Â¨âˆ¾(âŠ(âˆ¾â—‹<)Â¨(2âŠ¸â†“))Â¨data
dist â† (âŒŠËâˆ˜+â‰1â€¿âˆ)âŸ(â‰ nodes)Ëœ {ğ•¨â‰¡ğ•© ? 0; âŠ‘pairsâˆŠËœâ‹ˆâŸ¨ğ•¨,ğ•©âŸ© ? 1; âˆ}âŒœËœâ†•â‰ nodes
To_visit â† (>â—‹âŠ‘)_to_heap
to_visit.Push<âŸ¨0, 0, 0, (0âŠ¸=)Â¨â†•â‰ nodesâŸ©   # is a heap of âŸ¨flow, time, position, bitmapâŸ© 
visited â† âˆ˜â€¿2â¥ŠâŸ¨âŸ¨0, 0, (0âŠ¸=)Â¨â†•â‰ nodesâŸ©, 0âŸ© # is a map from âŸ¨time, position, bitmapâŸ© to flow
Expand â† {limit ğ•Š âŸ¨flow, time, pos, statesâŸ©:
  {ğ•Š âŸ¨p,costâŸ©:
    t â† 1+time+cost
    {(0=cost)âˆ¨(pâŠ‘states)âˆ¨(limitâ‰¤t)âˆ¨(0=1âŠ‘pâŠ‘data) ?@;
      f â† flow + (limit-t)Ã—1âŠ‘pâŠ‘data
      s â† 1Ë™âŒ¾(pâŠ¸âŠ‘)states 
      key_index â† âŠ‘(âŠ‘Ë˜visited)âŠâŸ¨key â† âŸ¨t,p,sâŸ©âŸ©
      {key_index<â‰ visited ?@; visited (âˆ¾âŸœ(âˆ˜â€¿2â¥ŠâŸ¨key,0âŸ©))â†©} # ensure the key exists
      {f â‰¤ âŒˆÂ´(({(tâ‰¥âŠ‘ğ•©)âˆ§(key â‰¡â—‹(1â†“âŠ‘) ğ•©)}âˆ˜âŠ‘)Â¨)âŠ¸/âŸœ((1âŠ¸âŠ‘)Â¨)â¥Š<Ë˜visited ?@;
        to_visit.Push<âŸ¨f,t,p,sâŸ©
        visited â†© fË™âŒ¾(key_indexâ€¿1âŠ¸âŠ‘) visited
      }
    }
  }Â¨ ((â†•â‰ )â‹ˆÂ¨âŠ¢) posâŠdist
}
Search â† {F limit:
  cand â† 0
  While {ğ•¤â‹„ Â¬to_visit.Empty @}â€¿{ğ•¤â‹„ state â† to_visit.Pop @â‹„ cand â†© candâŒˆâŠ‘stateâ‹„ limit Expand state}
  cand
}
â€¢Show Search 30

To_check â† (>â—‹âŠ‘)_to_heap
to_check.Push<âŸ¨0, (0âŠ¸=)Â¨â†•â‰ nodes, âŸ¨0, 0âŸ©, âŸ¨0, 0âŸ©âŸ©     # âŸ¨flow, map, âŸ¨time1, position1âŸ©, âŸ¨time1, pisition1âŸ©âŸ© 
# checked â† âˆ˜â€¿2â¥ŠâŸ¨(0âŠ¸=)Â¨â†•â‰ nodesâŸ©, âŸ¨0, 0âŸ©, âŸ¨0, 0âŸ©âŸ©, 0âŸ© # âŸ¨map, âŸ¨time1, position1âŸ©, âŸ¨time1, pisition1âŸ©, flowâŸ© 
# Expand â† {limit ğ•Š âŸ¨flow, time, pos, statesâŸ©:
#   {ğ•Š âŸ¨p,costâŸ©:
#     t â† 1+time+cost
#     {(0=cost)âˆ¨(pâŠ‘states)âˆ¨(limitâ‰¤t)âˆ¨(0=1âŠ‘pâŠ‘data) ?@;
#       f â† flow + (limit-t)Ã—1âŠ‘pâŠ‘data
#       s â† 1Ë™âŒ¾(pâŠ¸âŠ‘)states 
#       key_index â† âŠ‘(âŠ‘Ë˜checked)âŠâŸ¨key â† âŸ¨t,p,sâŸ©âŸ©
#       {key_index<â‰ checked ?@; checked (âˆ¾âŸœ(âˆ˜â€¿2â¥ŠâŸ¨key,0âŸ©))â†©} # ensure the key exists
#       {f â‰¤ âŒˆÂ´(({(tâ‰¥âŠ‘ğ•©)âˆ§(key â‰¡â—‹(1â†“âŠ‘) ğ•©)}âˆ˜âŠ‘)Â¨)âŠ¸/âŸœ((1âŠ¸âŠ‘)Â¨)â¥Š<Ë˜checked ?@;
#         to_check.Push<âŸ¨f,t,p,sâŸ©
#         checked â†© fË™âŒ¾(key_indexâ€¿1âŠ¸âŠ‘) checked
#       }
#     }
#   }Â¨ ((â†•â‰ )â‹ˆÂ¨âŠ¢) posâŠdist
# }
# Search2 â† {F limit:
#   cand â† 0
#   While {ğ•¤â‹„ Â¬to_check.Empty @}â€¿{ğ•¤â‹„ state â† to_check.Pop @â‹„ cand â†© candâŒˆâŠ‘stateâ‹„ limit Expand state}
#   cand
# }
# â€¢Show Search2 26
