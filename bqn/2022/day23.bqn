Solve â‡ {envâ€¿part ğ•Š data :
  lib â† â€¢Import "/util.bqn"âˆ¾Ëœ"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  âŸ¨HashMapâŸ©â€¿âŸ¨HashSetâŸ© â† â€¢ImportÂ¨"/hashmap.bqn"â€¿"/hashset.bqn"âˆ¾ËœÂ¨<"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  data '#'âŠ¸=âˆ˜> â†©
  Moves â† {mapâ€¿r ğ•Š ğ•© :
    ToN â† {yâ€¿x : âŸ¨y-1,  xâŸ©} # â‹„ !0â€¿0  â‰¡ ToN 1â€¿0
    ToS â† {yâ€¿x : âŸ¨y+1,  xâŸ©} # â‹„ !2â€¿0  â‰¡ ToS 1â€¿0
    ToW â† {yâ€¿x : âŸ¨  y,x-1âŸ©} # â‹„ !0â€¿1  â‰¡ ToW 0â€¿2
    ToE â† {yâ€¿x : âŸ¨  y,x+1âŸ©} # â‹„ !1â€¿10 â‰¡ ToE 1â€¿9
    (r-1)âŒ½âŸ¨ToN ğ•©,ToS ğ•©,ToW ğ•©,ToE ğ•©âŸ©
  }
  Avls â† {mapâ€¿r ğ•Š yâ€¿x :
    {
      1â‰¥+Â´map.HasÂ¨â¥Šyâ€¿xâŠ¸+Â¨Â¯1+â†•3â€¿3 ? 4â†‘0 ;
      avN â† {Â¬map.HasâŸ¨y-1,x-1âŸ© ? Â¬map.HasâŸ¨y-1,x  âŸ© ? Â¬map.HasâŸ¨y-1,x+1âŸ© ? map.HasâŸ¨y,xâŸ© ; 0}
      avS â† {Â¬map.HasâŸ¨y+1,x-1âŸ© ? Â¬map.HasâŸ¨y+1,x  âŸ© ? Â¬map.HasâŸ¨y+1,x+1âŸ© ? map.HasâŸ¨y,xâŸ© ; 0}
      avW â† {Â¬map.HasâŸ¨y-1,x-1âŸ© ? Â¬map.HasâŸ¨y  ,x-1âŸ© ? Â¬map.HasâŸ¨y+1,x-1âŸ© ? map.HasâŸ¨y,xâŸ© ; 0}
      avE â† {Â¬map.HasâŸ¨y-1,x+1âŸ© ? Â¬map.HasâŸ¨y  ,x+1âŸ© ? Â¬map.HasâŸ¨y+1,x+1âŸ© ? map.HasâŸ¨y,xâŸ© ; 0}
      (r-1)âŒ½âŸ¨avN,avS,avW,avEâŸ©
    }
  }
  Locations â† Avls/Moves            # at most 4 cands
  NextLocation â† (Â¬âˆ˜â‰ âŠ¸â†“)âˆ˜Locations  # at most 1 location
  { # test hashmap1
    h â† HashmapËœâŸ¨âŸ©
    0 h.Set 1
    "h.get/1" lib.Debug h.Get 0
    0 h.Set 1+ 0 h.Get 0
    "h.get/1" lib.Debug h.Get 0
  }
  {
    0=part ?
      Embed â† Â¯10âŠ¸(âŒ½â‰1)Â·Â¯10âŠ¸âŒ½(20+â‰¢)âŠ¸â†‘
      data â†© Embed data
      hâ€¿w â† â‰¢data
      Avls â† {mapâ€¿r ğ•Š yâ€¿x :
        {
          (0=y)âˆ¨(0=x)âˆ¨(y=h)âˆ¨(x=w) ? 4â†‘0 ;
          1â‰¥+Â´({yâ€¿x : (0â‰¤y)âˆ§(0â‰¤x)âˆ§(y<h)âˆ§(x<w)}Â¨âŠ¸/â¥Šyâ€¿xâŠ¸+Â¨Â¯1+â†•3â€¿3)âŠ‘map ? 4â†‘0 ;
          avN â† {(1<y)âˆ§(1â‰¤x)âˆ§(xâ‰¤w) ? Â¬âŸ¨y-1,x-1âŸ©âŠ‘map ? Â¬âŸ¨y-1,x  âŸ©âŠ‘map ? Â¬âŸ¨y-1,x+1âŸ©âŠ‘map ? âŸ¨y,xâŸ©âŠ‘map ; 0}
          avS â† {(h>y)âˆ§(1â‰¤x)âˆ§(xâ‰¤w) ? Â¬âŸ¨y+1,x-1âŸ©âŠ‘map ? Â¬âŸ¨y+1,x  âŸ©âŠ‘map ? Â¬âŸ¨y+1,x+1âŸ©âŠ‘map ? âŸ¨y,xâŸ©âŠ‘map ; 0}
          avW â† {(1â‰¤y)âˆ§(yâ‰¤h)âˆ§(1<x) ? Â¬âŸ¨y-1,x-1âŸ©âŠ‘map ? Â¬âŸ¨y  ,x-1âŸ©âŠ‘map ? Â¬âŸ¨y+1,x-1âŸ©âŠ‘map ? âŸ¨y,xâŸ©âŠ‘map ; 0}
          avE â† {(1â‰¤y)âˆ§(yâ‰¤h)âˆ§(w>x) ? Â¬âŸ¨y-1,x+1âŸ©âŠ‘map ? Â¬âŸ¨y  ,x+1âŸ©âŠ‘map ? Â¬âŸ¨y+1,x+1âŸ©âŠ‘map ? âŸ¨y,xâŸ©âŠ‘map ; 0}
          (r-1)âŒ½âŸ¨avN,avS,avW,avEâŸ©
        }
      }
      Locations â† Avls/Moves            # at most 4 cands
      NextLocation â† (Â¬âˆ˜â‰ âŠ¸â†“)âˆ˜Locations  # at most 1 location
      CountGround â† {ğ•Š m :              # sum of empty cells
        "" lib.Debug m
        "area" lib.Debug area â† Ã—Â´(Â¬Â´Â¯1â€¿0âŠâˆ§)Ë˜â‰>alive â† âŠ‘âŸœmÂ¨âŠ¸/â¥Šâ†•â‰¢m
        area-â‰ alive
      }
      CountGround 1âŠ‘{stepâ€¿data :
        0 lib.Progress destination â† {dataâ€¿(4|step) NextLocation ğ•©}Â¨â†•â‰¢data
        # Aggregate congestion map by using a tricky 0â†’1â†’âˆ counter then collapse elements by (1=â‰ )
        0 lib.Progress movedElves â† 1=congestion â† (dataâ‰¢âŠ¸â†‘0){ğ•¨ğ•Šğ•© : (Ã·0âŠ¸=)âŒ¾(ğ•¨âŠ¸âŠ‘)ğ•©}Â´â¥Š>âŸ¨âŸ©âŠ¸â‰¢Â¨âŠ¸/â¥Šdestination
        # Erase Elves from data if Â¬destinationâŠ‘congestion
        remainingElves â† {p â† ğ•©âŠ‘destination â‹„ âŸ¨âŸ©â‰¢p ? Â¬pâŠ‘âŠ¸âŠ‘movedElves ; ğ•©âŠ‘data}Â¨â†•â‰¢data
        âŸ¨1+step, remainingElvesâˆ¨movedElvesâŸ©
      }â€¢_while_(10â‰¥âŠ‘) 1â€¿data ;

    âŠ‘partâˆŠâŸ¨1,2âŸ© ?
      set â† HashSet(â¥ŠÂ·â†•â‰¢)âŠ¸((âŠ‘Â¨âŸœ<)/âŠ£)data
      Empties â† {râ€¿câ€¿set : alive â† âˆ§set.Valuesâ¼@ â‹„ aliveâ‰ âŠ¸(-Ëœ)Ã—Â´(Â¬Â´Â¯1â€¿0âŠâˆ§)Ë˜â‰>alive}
      Step â† {roundâ€¿movedâ€¿set :
        numElvesB â† set.Count@
        # build destination that map from Elf to the possible target position
        destinations â† (Â¬âˆ˜â‰ âŠ¸â†“)Â¨{setâ€¿(4|round) NextLocation ğ•©}Â¨set.Valuesâ¼@
        {0=round ?
          "destination" lib.Debug >â‹ˆÂ¨destinations
        ;0
        }
        ! numElvesB=â‰ destinations
        ! âˆ§Â´(1â‰¥â‰ )Â¨destinations
        congestion â† (HashMapËœâŸ¨âŸ©){ğ•¨ ğ•©.Set 1+0 ğ•©.Get ğ•¨}Â´â¥Š>âŸ¨âŸ©âŠ¸â‰¢Â¨âŠ¸/destinations
        {0=round ?
          "congestion" lib.Debug >â‹ˆÂ¨congestion.Valuesâ¼Ëœ@
          "building" lib.Debug â‰>(1=1âŠ¸âŠ‘)Â¨âŠ¸/congestion.Valuesâ¼Ëœ@
        ;0
        }
        movedElves â† HashSet{âŸ¨âŸ©: âŸ¨âŸ© ; âŠğ•©}â‰>(1=1âŠ¸âŠ‘)Â¨âŠ¸/congestion.Valuesâ¼Ëœ@
        # "moved" lib.Debug movedElves.Valuesâ¼Ëœ@
        continue â† 0<movedElves.Count@
        {continue ? 0 ; âˆ} lib.Progress round
        # Erase Elves from data if Â¬destinationâŠ‘congestion
        Pickup â† {nowâ€¿âŸ¨âŸ© : now ; nowâ€¿nexts : Â¬movedElves.Has âŠ‘nexts ? now ; âŸ¨âŸ©}
        # "now â†’ next" lib.Debug >destinationsâ‹ˆËœÂ¨set.Valuesâ¼@
        remainingElves â† (âŸ¨âŸ©âŠ¸â‰¢)Â¨âŠ¸/PickupÂ¨destinationsâ‹ˆËœÂ¨set.Valuesâ¼@
        movedElves{ğ•©.Set ğ•¨}Â´remainingElves
        numElvesA â† movedElves.Count@
        {0=round ?
          "before" lib.Debug â‰>set.Valuesâ¼@
          "count" lib.Debug â‰>movedElves.Valuesâ¼@
        ;0
        }
        âŸ¨round,numElvesA,numElvesBâŸ© ! numElvesA=numElvesB
        âŸ¨1+round,continue,movedElvesâŸ©
      }
      {
        1=part ? Empties Stepâ€¢_while_(10â‰¥âŠ‘) 1â€¿1â€¿set ;
        2=part ? (Â¯1+âŠ‘)  Stepâ€¢_while_(1âŠ¸âŠ‘)  1â€¿1â€¿set
      }
  }
}
