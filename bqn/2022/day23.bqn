Solve â‡ {envâ€¿part ğ•Š data :
  lib â† â€¢Import "/util.bqn"âˆ¾Ëœ"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  data '#'âŠ¸=âˆ˜> â†©
  Moves â† {mapâ€¿r ğ•Š ğ•© :
    ToN â† {yâ€¿x : âŸ¨y-1,  xâŸ©} # â‹„ !0â€¿0  â‰¡ ToN 1â€¿0
    ToS â† {yâ€¿x : âŸ¨y+1,  xâŸ©} # â‹„ !2â€¿0  â‰¡ ToS 1â€¿0
    ToW â† {yâ€¿x : âŸ¨  y,x-1âŸ©} # â‹„ !0â€¿1  â‰¡ ToW 0â€¿2
    ToE â† {yâ€¿x : âŸ¨  y,x+1âŸ©} # â‹„ !1â€¿10 â‰¡ ToE 1â€¿9
    (r-1)âŒ½âŸ¨ToN ğ•©,ToS ğ•©,ToW ğ•©,ToE ğ•©âŸ©
  }
  {
    0=part ?
      Embed â† Â¯10âŠ¸(âŒ½â‰1)Â·Â¯10âŠ¸âŒ½(20+â‰¢)âŠ¸â†‘
      data â†© Embed data
      hâ€¿w â† â‰¢data
      Avls â† {mapâ€¿r ğ•Š yâ€¿x :
        {
          (0=y)âˆ¨(0=x)âˆ¨(y=h)âˆ¨(x=w) ? 4â†‘0 ;
          1â‰¥+Â´({yâ€¿x : (0â‰¤y)âˆ§(0â‰¤x)âˆ§(y<h)âˆ§(x<w)}Â¨âŠ¸/â¥Šyâ€¿xâŠ¸+Â¨Â¯1+â†•3â€¿3)âŠ‘map ? 4â†‘0 ;
          avN â† {(1<y)âˆ§(1â‰¤x)âˆ§(xâ‰¤w) ? Â¬âŸ¨y-1,x-1âŸ©âŠ‘map ? Â¬âŸ¨y-1,x  âŸ©âŠ‘map ? Â¬âŸ¨y-1,x+1âŸ©âŠ‘map ? âŸ¨y,xâŸ©âŠ‘map ; 0}
          avS â† {(h>y)âˆ§(1â‰¤x)âˆ§(xâ‰¤w) ? Â¬âŸ¨y+1,x-1âŸ©âŠ‘map ? Â¬âŸ¨y+1,x  âŸ©âŠ‘map ? Â¬âŸ¨y+1,x+1âŸ©âŠ‘map ? âŸ¨y,xâŸ©âŠ‘map ; 0}
          avW â† {(1â‰¤y)âˆ§(yâ‰¤h)âˆ§(1<x) ? Â¬âŸ¨y-1,x-1âŸ©âŠ‘map ? Â¬âŸ¨y  ,x-1âŸ©âŠ‘map ? Â¬âŸ¨y+1,x-1âŸ©âŠ‘map ? âŸ¨y,xâŸ©âŠ‘map ; 0}
          avE â† {(1â‰¤y)âˆ§(yâ‰¤h)âˆ§(w>x) ? Â¬âŸ¨y-1,x+1âŸ©âŠ‘map ? Â¬âŸ¨y  ,x+1âŸ©âŠ‘map ? Â¬âŸ¨y+1,x+1âŸ©âŠ‘map ? âŸ¨y,xâŸ©âŠ‘map ; 0}
          (r-1)âŒ½âŸ¨avN,avS,avW,avEâŸ©
        }
      }
      Locations â† Avls/Moves            # at most 4 cands
      NextLocation â† (Â¬âˆ˜â‰ âŠ¸â†“)âˆ˜Locations  # at most 1 location
      CountGround â† {ğ•Š m :              # sum of empty cells
        "" lib.Debug m
        "area" lib.Debug area â† Ã—Â´(Â¬Â´Â¯1â€¿0âŠâˆ§)Ë˜â‰>alive â† âŠ‘âŸœmÂ¨âŠ¸/â¥Šâ†•â‰¢m
        area-â‰ alive
      }
      CountGround 1âŠ‘{stepâ€¿data :
        0 lib.Progress destination â† {dataâ€¿(4|step) NextLocation ğ•©}Â¨â†•â‰¢data
        # Aggregate congestion map by using a tricky 0â†’1â†’âˆ counter then collapse elements by (1=â‰ )
        0 lib.Progress movedElves â† 1=congestion â† (dataâ‰¢âŠ¸â†‘0){ğ•¨ğ•Šğ•© : (Ã·0âŠ¸=)âŒ¾(ğ•¨âŠ¸âŠ‘)ğ•©}Â´â¥Š>âŸ¨âŸ©âŠ¸â‰¢Â¨âŠ¸/â¥Šdestination
        # Erase Elves from data if Â¬destinationâŠ‘congestion
        remainingElves â† {p â† ğ•©âŠ‘destination â‹„  âŸ¨âŸ©â‰¢p ? Â¬pâŠ‘âŠ¸âŠ‘movedElves ; ğ•©âŠ‘data}Â¨â†•â‰¢data
        âŸ¨1+step, remainingElvesâˆ¨movedElvesâŸ©
      }â€¢_while_(10â‰¥âŠ‘) 1â€¿data ;
    1=part ?
      âŸ¨HashMapâŸ©â€¿âŸ¨HashSetâŸ© â† â€¢ImportÂ¨"/hashmap.bqn"â€¿"/hashset.bqn"âˆ¾ËœÂ¨<"." env.VarâŒ¾â‹ˆ "BQN_LIB"
      set â† HashSet(â¥ŠÂ·â†•â‰¢)âŠ¸((âŠ‘Â¨âŸœ<)/âŠ£)data
      Avls â† {mapâ€¿r ğ•Š yâ€¿x :
        {
          1â‰¥+Â´map.HasÂ¨â¥Šyâ€¿xâŠ¸+Â¨Â¯1+â†•3â€¿3 ? 4â†‘0 ;
          avN â† {Â¬map.HasâŸ¨y-1,x-1âŸ© ? Â¬map.HasâŸ¨y-1,x  âŸ© ? Â¬map.HasâŸ¨y-1,x+1âŸ© ? map.HasâŸ¨y,xâŸ© ; 0}
          avS â† {Â¬map.HasâŸ¨y+1,x-1âŸ© ? Â¬map.HasâŸ¨y+1,x  âŸ© ? Â¬map.HasâŸ¨y+1,x+1âŸ© ? map.HasâŸ¨y,xâŸ© ; 0}
          avW â† {Â¬map.HasâŸ¨y-1,x-1âŸ© ? Â¬map.HasâŸ¨y  ,x-1âŸ© ? Â¬map.HasâŸ¨y+1,x-1âŸ© ? map.HasâŸ¨y,xâŸ© ; 0}
          avE â† {Â¬map.HasâŸ¨y-1,x+1âŸ© ? Â¬map.HasâŸ¨y  ,x+1âŸ© ? Â¬map.HasâŸ¨y+1,x+1âŸ© ? map.HasâŸ¨y,xâŸ© ; 0}
          (r-1)âŒ½âŸ¨avN,avS,avW,avEâŸ©
        }
      }
      Locations â† Avls/Moves            # at most 4 cands
      NextLocation â† (Â¬âˆ˜â‰ âŠ¸â†“)âˆ˜Locations  # at most 1 location
      CountGround â† {ğ•Š set :            # sum of empty cells
        alive â† âˆ§set.AsList@
        aliveâ‰ âŠ¸(-Ëœ)Ã—Â´(Â¬Â´Â¯1â€¿0âŠâˆ§)Ë˜â‰>alive
      }
      CountGround 1âŠ‘{stepâ€¿set :
        # build destination that map from Elf to the possible target position
        destinations â† (Â¬âˆ˜â‰ âŠ¸â†“)Â¨{setâ€¿(4|step) NextLocation ğ•©}Â¨set.AsList@
        congestion â† HashMapËœâŸ¨âŸ©
        congestion.SetâŸœ(1+0âŠ¸congestion.Get)ËœÂ¨â¥Š>âŸ¨âŸ©âŠ¸â‰¢Â¨âŠ¸/destinations
        movedElves â† HashSetâŠâ‰>(1=1âŠ¸âŠ‘)Â¨âŠ¸/congestion.Valuesâ¼Ëœ@
        # Erase Elves from data if Â¬destinationâŠ‘congestion
        Pickup â† {
          nowâ€¿âŸ¨âŸ©   : now ;
          nowâ€¿nexts :
            Â¬movedElves.Has âŠ‘nexts ? now ;
          âŸ¨âŸ©
        }
        # "now â†’ next" lib.Debug >destinationsâ‹ˆËœÂ¨set.AsList@
        remainingElves â† (âŸ¨âŸ©âŠ¸â‰¢)Â¨âŠ¸/PickupÂ¨destinationsâ‹ˆËœÂ¨set.AsList@
        movedElves{ğ•©.Set ğ•¨}Â´remainingElves
        step ! (set.Count@)=movedElves.Count@
        âŸ¨1+step, movedElvesâŸ©
      }â€¢_while_(10â‰¥âŠ‘) 1â€¿set ;
    1=part ?
      âŸ¨HashMapâŸ©â€¿âŸ¨HashSetâŸ© â† â€¢ImportÂ¨"/hashmap.bqn"â€¿"/hashset.bqn"âˆ¾ËœÂ¨<"." env.VarâŒ¾â‹ˆ "BQN_LIB"
      set â† HashSet(â¥ŠÂ·â†•â‰¢)âŠ¸((âŠ‘Â¨âŸœ<)/âŠ£)data
      Avls â† {mapâ€¿r ğ•Š yâ€¿x :
        {
          1â‰¥+Â´map.HasÂ¨â¥Šyâ€¿xâŠ¸+Â¨Â¯1+â†•3â€¿3 ? 4â†‘0 ;
          avN â† {Â¬map.HasâŸ¨y-1,x-1âŸ© ? Â¬map.HasâŸ¨y-1,x  âŸ© ? Â¬map.HasâŸ¨y-1,x+1âŸ© ? map.HasâŸ¨y,xâŸ© ; 0}
          avS â† {Â¬map.HasâŸ¨y+1,x-1âŸ© ? Â¬map.HasâŸ¨y+1,x  âŸ© ? Â¬map.HasâŸ¨y+1,x+1âŸ© ? map.HasâŸ¨y,xâŸ© ; 0}
          avW â† {Â¬map.HasâŸ¨y-1,x-1âŸ© ? Â¬map.HasâŸ¨y  ,x-1âŸ© ? Â¬map.HasâŸ¨y+1,x-1âŸ© ? map.HasâŸ¨y,xâŸ© ; 0}
          avE â† {Â¬map.HasâŸ¨y-1,x+1âŸ© ? Â¬map.HasâŸ¨y  ,x+1âŸ© ? Â¬map.HasâŸ¨y+1,x+1âŸ© ? map.HasâŸ¨y,xâŸ© ; 0}
          (r-1)âŒ½âŸ¨avN,avS,avW,avEâŸ©
        }
      }
      Locations â† Avls/Moves            # at most 4 cands
      NextLocation â† (Â¬âˆ˜â‰ âŠ¸â†“)âˆ˜Locations  # at most 1 location
      CountGround â† {ğ•Š set :            # sum of empty cells
        alive â† âˆ§set.AsList@
        aliveâ‰ âŠ¸(-Ëœ)Ã—Â´(Â¬Â´Â¯1â€¿0âŠâˆ§)Ë˜â‰>alive
      }
      CountGround 1âŠ‘{stepâ€¿set :
        # build destination that map from Elf to the possible target position
        destinations â† (Â¬âˆ˜â‰ âŠ¸â†“)Â¨{setâ€¿(4|step) NextLocation ğ•©}Â¨set.AsList@
        congestion â† HashMapËœâŸ¨âŸ©
        congestion.SetâŸœ(1+0âŠ¸congestion.Get)ËœÂ¨â¥Š>âŸ¨âŸ©âŠ¸â‰¢Â¨âŠ¸/destinations
        movedElves â† HashSetâŠâ‰>(1=1âŠ¸âŠ‘)Â¨âŠ¸/congestion.Valuesâ¼Ëœ@
        # Erase Elves from data if Â¬destinationâŠ‘congestion
        Pickup â† {
          nowâ€¿âŸ¨âŸ©   : now ;
          nowâ€¿nexts :
            Â¬movedElves.Has âŠ‘nexts ? now ;
          âŸ¨âŸ©
        }
        # "now â†’ next" lib.Debug >destinationsâ‹ˆËœÂ¨set.AsList@
        remainingElves â† (âŸ¨âŸ©âŠ¸â‰¢)Â¨âŠ¸/PickupÂ¨destinationsâ‹ˆËœÂ¨set.AsList@
        movedElves{ğ•©.Set ğ•¨}Â´remainingElves
        step ! (set.Count@)=movedElves.Count@
        âŸ¨1+step, movedElvesâŸ©
      }â€¢_while_(10â‰¥âŠ‘) 1â€¿set
  }
}
