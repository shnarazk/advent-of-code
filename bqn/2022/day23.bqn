Solve â‡ {envâ€¿part ğ•Š data :
  lib â† "." env.VarâŒ¾â‹ˆ "BQN_LIB"
  utilâ€¿âŸ¨HashMapâŸ©â€¿âŸ¨HashSetâŸ© â† â€¢ImportÂ¨"/util.bqn"â€¿"/hashmap.bqn"â€¿"/hashset.bqn"âˆ¾ËœÂ¨<lib
  Moves â† {mapâ€¿r ğ•Š yâ€¿x :
    toN â† {âŸ¨y-1,  xâŸ©}
    toS â† {âŸ¨y+1,  xâŸ©}
    toW â† {âŸ¨  y,x-1âŸ©}
    toE â† {âŸ¨  y,x+1âŸ©}
    (r-1)âŒ½âŸ¨toN,toS,toW,toEâŸ©
  }
  Avls â† {mapâ€¿r ğ•Š yâ€¿x :
    {
      1â‰¥+Â´map.HasÂ¨â¥Šyâ€¿xâŠ¸+Â¨Â¯1+â†•3â€¿3 ? 4â†‘0 ;
      avN â† {Â¬map.HasâŸ¨y-1,x-1âŸ© ? Â¬map.HasâŸ¨y-1,x  âŸ© ? Â¬map.HasâŸ¨y-1,x+1âŸ© ? map.HasâŸ¨y,xâŸ© ; 0}
      avS â† {Â¬map.HasâŸ¨y+1,x-1âŸ© ? Â¬map.HasâŸ¨y+1,x  âŸ© ? Â¬map.HasâŸ¨y+1,x+1âŸ© ? map.HasâŸ¨y,xâŸ© ; 0}
      avW â† {Â¬map.HasâŸ¨y-1,x-1âŸ© ? Â¬map.HasâŸ¨y  ,x-1âŸ© ? Â¬map.HasâŸ¨y+1,x-1âŸ© ? map.HasâŸ¨y,xâŸ© ; 0}
      avE â† {Â¬map.HasâŸ¨y-1,x+1âŸ© ? Â¬map.HasâŸ¨y  ,x+1âŸ© ? Â¬map.HasâŸ¨y+1,x+1âŸ© ? map.HasâŸ¨y,xâŸ© ; 0}
      (r-1)âŒ½âŸ¨avN,avS,avW,avEâŸ©
    }
  }
  Locations â† Avls/Moves                    # at most 4 cands
  NextLocation â† (Â¬âˆ˜â‰ âŠ¸â†“)âˆ˜Locations          # at most 1 location
  Empties â† {râ€¿câ€¿set : alive â† âˆ§set.Valuesâ¼@ â‹„ aliveâ‰ âŠ¸(-Ëœ)Ã—Â´(Â¬Â´Â¯1â€¿0âŠâˆ§)Ë˜â‰>alive}
  Step â† {roundâ€¿movedâ€¿set : 
    destinations â† (Â¬âˆ˜â‰ âŠ¸â†“)Â¨{setâ€¿(4|round) NextLocation ğ•©}Â¨set.Valuesâ¼@
    congestion â† (HashMapËœâŸ¨âŸ©){ğ•¨ ğ•©.Set 1+0 ğ•©.Get ğ•¨}Â´â¥Š>âŸ¨âŸ©âŠ¸â‰¢Â¨âŠ¸/destinations
    elves â† HashSet{âŸ¨âŸ©: âŸ¨âŸ© ; âŠğ•©}â‰>(1=1âŠ¸âŠ‘)Â¨âŠ¸/congestion.Valuesâ¼Ëœ@
    continue â† 0<elves.Count@
    {continue ? util.Progress round ; âˆ util.Progress round}  
    Move â† {nowâ€¿âŸ¨âŸ© : elves.Set now ; nowâ€¿âŸ¨nextâŸ© : Â¬elves.Has next ? elves.Set now ; âŸ¨âŸ©}
    MoveÂ¨destinationsâ‹ˆËœÂ¨set.Valuesâ¼@
    âŸ¨1+round,continue,elvesâŸ©
  }
  set â† HashSet(â¥ŠÂ·â†•â‰¢)âŠ¸((âŠ‘Â¨âŸœ<)/âŠ£)'#'=>data
  {
    1=part ? Empties Stepâ€¢_while_(10â‰¥âŠ‘) 1â€¿1â€¿set ;
    2=part ? (Â¯1+âŠ‘)  Stepâ€¢_while_(1âŠ¸âŠ‘)  1â€¿1â€¿set
  }
}
