Solve â‡ {envâ€¿part ğ•Š data :
  lib â† "." env.VarâŒ¾â‹ˆ "BQN_LIB"
  utilâ€¿âŸ¨HashMapâŸ©â€¿âŸ¨HashSetâŸ© â† â€¢ImportÂ¨"/util.bqn"â€¿"/hashmap.bqn"â€¿"/hashset.bqn"âˆ¾ËœÂ¨<lib
  Moves â† {mapâ€¿r ğ•Š yâ€¿x : (r-1)âŒ½âŸ¨âŸ¨y-1,xâŸ©,âŸ¨y+1,xâŸ©,âŸ¨y,x-1âŸ©,âŸ¨y,x+1âŸ©âŸ©}
  dirs â† 0â€¿0âŠ¸â‰¢Â¨âŠ¸/â¥ŠÂ¯1+â†•3â€¿3
  Avls â† {
    Â¬(âŠ‘ğ•¨).Hasğ•© ? 4â†‘0 ;
    mapâ€¿r â† ğ•¨
    nwâ€¿nâ€¿neâ€¿wâ€¿eâ€¿swâ€¿sâ€¿se â† Â¬map.Hasâˆ˜(ğ•©âŠ¸+)Â¨dirs
    dirs â† âˆ§Â´Â¨âŸ¨âŸ¨nw,n,neâŸ©,âŸ¨sw,s,seâŸ©,âŸ¨nw,w,swâŸ©,âŸ¨ne,e,seâŸ©âŸ©
    {âˆ§Â´dirs ? 4â†‘0 ; (r-1)âŒ½dirs}
  }
  Locations â† Avls/Moves                    # at most 4 cands
  NextLocation â† (Â¬âˆ˜â‰ âŠ¸â†“)âˆ˜Locations          # at most 1 location
  Empties â† {râ€¿câ€¿set : alive â† âˆ§set.Valuesâ¼@ â‹„ aliveâ‰ âŠ¸(-Ëœ)Ã—Â´(Â¬Â´Â¯1â€¿0âŠâˆ§)Ë˜â‰>alive}
  Step â† {roundâ€¿movedâ€¿set :
    destinations â† (Â¬âˆ˜â‰ âŠ¸â†“)Â¨{setâ€¿(4|round) NextLocation ğ•©}Â¨set.Valuesâ¼@
    congestion â† (HashMapËœâŸ¨âŸ©){ğ•¨ ğ•©.Set 1+0 ğ•©.Get ğ•¨}Â´â¥Š>âŸ¨âŸ©âŠ¸â‰¢Â¨âŠ¸/destinations
    elves â† HashSet{âŸ¨âŸ©: âŸ¨âŸ© ; âŠğ•©}â‰>(1=1âŠ¸âŠ‘)Â¨âŠ¸/congestion.Valuesâ¼Ëœ@
    continue â† 0<elves.Count@
    util.Progress round
    Move â† {nowâ€¿âŸ¨âŸ© : elves.Set now ; nowâ€¿âŸ¨nextâŸ© : Â¬elves.Has next ? elves.Set now ; âŸ¨âŸ©}
    MoveÂ¨destinationsâ‹ˆËœÂ¨set.Valuesâ¼@
    âŸ¨1+round,continue,elvesâŸ©
  }
  set â† HashSet(â¥ŠÂ·â†•â‰¢)âŠ¸((âŠ‘Â¨âŸœ<)/âŠ£)'#'=>data
  {
    1=part ? Empties Stepâ€¢_while_(10â‰¥âŠ‘) 1â€¿1â€¿set ;
    2=part ? (Â¯1+âŠ‘)  Stepâ€¢_while_(1âŠ¸âŠ‘)  1â€¿1â€¿set
  }
}
