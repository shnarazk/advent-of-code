Solve â‡ {envâ€¿part ğ•Š data :
  lib â† â€¢Import "/util.bqn"âˆ¾Ëœ"." env.VarâŒ¾â‹ˆ "BQN_LIB"
  data '#'âŠ¸=âˆ˜> â†©
  maxYâ€¿maxX â† â‰¢data
  "" lib.Debug âŠdata
  Avls â† {0ğ•Šğ•© ;
    AvN â† {yâ€¿x :      0<y} â‹„ !Â¬AvN 0â€¿0
    AvS â† {yâ€¿x : maxY>1+y} â‹„ !Â¬AvS (maxY-1)â€¿0
    AvW â† {yâ€¿x :      0<x} â‹„ !Â¬AvW 0â€¿0
    AvE â† {yâ€¿x : maxX>1+x} â‹„ !Â¬AvE 0â€¿(maxX-1)
    ğ•¨âŒ½âŸ¨AvN ğ•©,AvS ğ•©,AvW ğ•©,AvE ğ•©âŸ©
  }
  "" lib.Debug Avls 0â€¿0
  Moves â† {0ğ•Šğ•© ;
    ToN â† {yâ€¿x : âŸ¨y-1,  xâŸ©} â‹„ !0â€¿0 â‰¡ ToN 1â€¿0
    ToS â† {yâ€¿x : âŸ¨y+1,  xâŸ©} â‹„ !2â€¿0 â‰¡ ToS 1â€¿0
    ToW â† {yâ€¿x : âŸ¨  y,x-1âŸ©} â‹„ !0â€¿1 â‰¡ ToW 0â€¿2
    ToE â† {yâ€¿x : âŸ¨  y,x+1âŸ©} â‹„ !1â€¿10 â‰¡ ToE 1â€¿9
    ğ•¨âŒ½âŸ¨ToN ğ•©,ToS ğ•©,ToW ğ•©,ToE ğ•©âŸ©
  }
  Locations â† {mapâ€¿r ğ•Š pos : (âŠ‘âŸœmap)Â¨âŠ¸/r(Avls/Moves)pos} # at most 4 cands
  NextLocation â† Â¬âˆ˜â‰ âŠ¸â†“Locations                          # at most 1 location
  CountGround â† {<â¼+Ë+ËÂ¬ğ•©}                               # sum of empty cells
  {
    1=part ?
      CountGround 1âŠ‘{stepâ€¿data :
        # data Â¬Â¨ â†©
        lib.Progress{â‰ dataâ€¿(4|step) NextLocation ğ•©}Â¨â†•â‰¢data
        # Plan
        # 1. aggregate destination map,
        # 2. then agregate congestion map
        # 3. collapse elements by (1=â‰ )
        # 4. filter Elf if Â¬destinationâŠ‘congestion, then add it to congestion map
        # 5. update ğ•© with it
        k â† 10âŠ¸â†‘Ë˜10â†‘data
        # lib.Progress â€¢Fmt k
        â€¢Delay 0.8
        âŸ¨1+step, dataâŸ©
      }â€¢_while_(10>âŠ‘) 0â€¿data ;
    2=part ? 0
  }
}
