lib â† â€¢Import "../lib.bqn"

Inject â† {
 âŸ¨âŸ© ğ•Š m: m;
  s ğ•Š m:
    m {
      begâ€¿end ğ•Š m:
        dxâ€¿dy â† end-beg
        seq â† {
          0<dy ? (â‹ˆâŸœ(0âŠ‘beg))Â¨(1âŠ‘beg)+â†•1+|dy;
          0>dy ? (â‹ˆâŸœ(0âŠ‘end))Â¨(1âŠ‘end)+â†•1+|dy;
          0<dx ? ((1âŠ‘beg)âŠ¸â‹ˆ)Â¨(0âŠ‘beg)+â†•1+|dx;
          0>dx ? ((1âŠ‘end)âŠ¸â‹ˆ)Â¨(0âŠ‘end)+â†•1+|dx;
           ! 0
        }
        (1Ë™Â¨seq)âŒ¾(seqâŠ¸âŠ‘) m
    }Â´â¥Šâ‹ˆË˜2â†•s
}
Drop â† { part ğ•Š map:
  abyss â† âŠ‘â‰¢map
  yâ€¿x â† start â† 0â€¿500
  fallingâ€¿hasRoom â† 1â€¿1
  lib.While { ğ•¤â‹„ falling } â€¿ { ğ•¤ â‹„
    new_y â† 1+y
    {
      abyss=new_y ? map 1Ë™âŒ¾(yâ€¿xâŠ¸âŠ‘) â†© â‹„ fallingâ€¿hasRoom â†© 0â€¿(part=2);
      (new_yâ€¿x (Â¬âŠ‘) map) ? y â†© new_y ;
      (new_yâ€¿(Â¯1+x) (Â¬âŠ‘) map) ? yâ€¿x â†© new_yâ€¿(Â¯1+x) ;
      (new_yâ€¿( 1+x) (Â¬âŠ‘) map) ? yâ€¿x â†© new_yâ€¿( 1+x) ;
      map 1Ë™âŒ¾(yâ€¿xâŠ¸âŠ‘) â†© â‹„ fallingâ€¿hasRoom â†© 0â€¿(start â‰¢ yâ€¿x)
    }
  }
  hasRoomâ€¿map
}

Solve â‡ { part ğ•Š data:
  seg â† lib.ParseIntsÂ¨ data
  "geometry" lib.Debug xmaxâ€¿ymax â† (2âŠ¸+âŒˆÂ´)Â¨(Â¬â‹ˆâŠ¢)â—‹(2âŠ¸|Â¨â†•âˆ˜â‰ )âŠ¸{(â‹ˆâ—‹(/âŸœğ•©))Â´ ğ•¨} âˆ¾seg
  { 2=part ? xmax ymaxâŠ¸+ â†©; @ }
  segments â† {(Â¬â‹ˆâŠ¢)â—‹(2âŠ¸|Â¨â†•âˆ˜â‰ )âŠ¸{(â‹ˆÂ¨â—‹(/âŸœğ•©))Â´ ğ•¨} ğ•©}Â¨ seg
  map â† segments InjectÂ´Ëœ ymaxâ€¿xmaxâ¥Š 0Ë™â†•xmaxÃ—ymax
  continueâ€¿sands â† 1â€¿0
  lib.While { ğ•¤ â‹„ continue }â€¿{ ğ•¤ â‹„ continueâ€¿map â†© part Drop map â‹„ sands 1âŠ¸+ â†© }
  {1=part ? Â¯1+sands; sands}
}
