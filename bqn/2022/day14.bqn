lib â† â€¢Import "../lib.bqn"

InjectBlock â† {
 âŸ¨âŸ© ğ•Š m: m;
  s ğ•Š m:
    m { begâ€¿end ğ•Š m:
      dxâ€¿dy â† end-beg
      seq â† {
        0<dy ? (â‹ˆâŸœ(0âŠ‘beg))Â¨(1âŠ‘beg)+â†•1+|dy;
        0>dy ? (â‹ˆâŸœ(0âŠ‘end))Â¨(1âŠ‘end)+â†•1+|dy;
        0<dx ? ((1âŠ‘beg)âŠ¸â‹ˆ)Â¨(0âŠ‘beg)+â†•1+|dx;
        0>dx ? ((1âŠ‘end)âŠ¸â‹ˆ)Â¨(0âŠ‘end)+â†•1+|dx;
         ! 0
      }
      (1Ë™Â¨seq)âŒ¾(seqâŠ¸âŠ‘) m
    }Â´â¥Šâ‹ˆË˜2â†•s
}
DropSand â† { part ğ•Š mapâ€¿trace:
  # ! 0â‰ â‰ trace
  abyss â† âŠ‘â‰¢map
  yâ€¿x â† start â† Â¯1âŠ‘trace
  falling â† 1
  lib.While { ğ•¤, falling } â€¿ { ğ•¤,
    new_y â† 1+y
    {
      abyss=new_y ?
        map 1Ë™âŒ¾(yâ€¿xâŠ¸âŠ‘) â†©
        { 1=part ? trace â†© âŸ¨âŸ© ; @ }
        trace Â¯1âŠ¸â†“ â†©
        falling â†© 0
        ;
      (new_yâ€¿x (Â¬âŠ‘) map) ?
        y â†© new_y
        trace âˆ¾âŸœâŸ¨yâ€¿xâŸ© â†©
        ;
      (new_yâ€¿(Â¯1+x) (Â¬âŠ‘) map) ?
        yâ€¿x â†© new_yâ€¿(Â¯1+x)
        trace âˆ¾âŸœâŸ¨yâ€¿xâŸ© â†©
        ;
      (new_yâ€¿( 1+x) (Â¬âŠ‘) map) ?
        yâ€¿x â†© new_yâ€¿( 1+x)
        trace âˆ¾âŸœâŸ¨yâ€¿xâŸ© â†©
      ;
        map 1Ë™âŒ¾(yâ€¿xâŠ¸âŠ‘) â†©,
        trace Â¯1âŠ¸â†“ â†©
        falling â†© 0
    }
  }
  mapâ€¿trace
}

Solve â‡ { part ğ•Š data:
  seg â† lib.ParseIntsÂ¨ data
  "geometry" lib.Debug xmaxâ€¿ymax â† (2âŠ¸+âŒˆÂ´)Â¨(Â¬â‹ˆâŠ¢)â—‹(2âŠ¸|Â¨â†•âˆ˜â‰ )âŠ¸{(â‹ˆâ—‹(/âŸœğ•©))Â´ ğ•¨} âˆ¾seg
  { 2=part ? xmax ymaxâŠ¸+ â†©; @ }
  segments â† {(Â¬â‹ˆâŠ¢)â—‹(2âŠ¸|Â¨â†•âˆ˜â‰ )âŠ¸{(â‹ˆÂ¨â—‹(/âŸœğ•©))Â´ ğ•¨} ğ•©}Â¨ seg
  map â† segments InjectBlockÂ´Ëœ ymaxâ€¿xmaxâ¥Š 0Ë™â†•xmaxÃ—ymax
  sandsâ€¿trace â† 0â€¿âŸ¨0â€¿500âŸ©
  lib.While { ğ•¤, 0<â‰ trace }â€¿{ ğ•¤
    mapâ€¿trace â†© part DropSand mapâ€¿trace
    sands 1âŠ¸+ â†©
    # "sandâ€¿trace" lib.Debug sandsâ€¿(â‰ trace)
  }
  {1=part ? Â¯1+sands; sands}
}
