lib â† â€¢Import "../lib.bqn"

sea_level â† Â¯100
IndexOf â† { âŠ‘(ğ•¨âŠ¸=âŠ‘âŸœğ•©)Â¨âŠ¸/â¥Šâ†•Â·â‰¢ ğ•© }
Choose â† { other ğ•Š self: {
    self âˆ§â—‹(0âŠ¸<) other  ? selfâŒŠ1+other;
    (0<other)âˆ§(other<âˆ) ? 1+other;
    self
  }
}
MakeNeighbor â† { (âŒ½â‰)âŸ(4-ğ•©)(âˆâŠ¸Â»Ë˜)(âŒ½â‰)âŸğ•© ğ•¨ }
Neighbors â† { (ğ•©âŠ¸MakeNeighbor)Â¨ â†•4 }
Dump â† { t ğ•Š ğ•©:
  lib.term.Up 1+â‰ ğ•©
  Colorize â† { ğ•©â‰¥ğ•¨ ? 80â€¿(âŒŠ255-255âŒŠâŒŠ2500Ã·âˆšğ•©)â€¿(âŒŠ255âŒŠ30Ã—1.8â‹†â¼ğ•©); 100â€¿100â€¿100 }
  { lib.term.Outlnâˆ¾{ ((t Colorize ğ•©) lib.color.RGB 0)âˆ¾" " }Â¨ğ•©â‹„ âŸ¨âŸ© }Ë˜ğ•©
}

Solve â‡ { part ğ•Š lines:
  shape â† (â‰ â‹ˆ(â‰ âŠ‘)) lines
  map â† (shapeâŠ¸â¥Š)âˆ˜(sea_levelâŠ¸+'a'âŠ¸(-Ëœ))âˆ˜âˆ¾ lines
  startâ€¿end â† (mapâŠ¸(IndexOfËœ)sea_levelâŠ¸+âˆ˜-âŸœ'a')Â¨ 'S'â€¿'E'
  map âŸ¨sea_level,sea_level+'z'-'a'âŸ©âŒ¾(startâ€¿endâŠ¸âŠ‘) â†©
  reachables â† { (â‰¢map)â¥Š(Â¯1+â¥Šmap)â‰¤â¥Šğ•© }Â¨ Neighbors map
  MaskedNeighbors â† reachables Ã— { (ğ•©âŠ¸MakeNeighbor)Â¨ â†•4 }

  n â† { 1=part ? m â† 1Ë™âŒ¾(startâŠ¸âŠ‘) map; { sea_level=ğ•© ? 1; ğ•© }Â¨Ë˜ map}
  lib.While { ğ•¤â‹„ 0>endâŠ‘n }â€¿{ ğ•¤â‹„ 0 Dump n (ChooseÂ¨Ë˜Â´âŸœ MaskedNeighbors) â†© }
  â€¢Out lib.term.resetâˆ¾lib.term.clear
  Â¯1âŠ¸+endâŠ¸âŠ‘ n
}
