lib â† â€¢Import"../lib.bqn"

sea_level â† Â¯100
IndexOf â† {âŠ‘(ğ•¨âŠ¸=âŠ‘âŸœğ•©)Â¨âŠ¸/â¥Šâ†•Â·â‰¢ğ•©}
Choose â† {other ğ•Š self : {
    selfâˆ§â—‹(0âŠ¸<)other    ? selfâŒŠ1+other ;
    (0<other)âˆ§(other<âˆ) ? 1+other ;
    self
  }
}
MakeNeighbor â† {(âŒ½â‰)âŸ(4-ğ•©)(âˆâŠ¸Â»Ë˜)(âŒ½â‰)âŸğ•© ğ•¨}
Neighbors â† {(ğ•©âŠ¸MakeNeighbor)Â¨â†•4}
Dump â† {t ğ•Š ğ•© :
  lib.term.Up 1+â‰ ğ•©
  Colorize â† {ğ•©â‰¥ğ•¨ ? 80â€¿(âŒŠ255-255âŒŠâŒŠ2500Ã·âˆšğ•©)â€¿(âŒŠ255âŒŠ30Ã—1.8â‹†â¼ğ•©) ; 100â€¿100â€¿100}
  {lib.term.Outlnâˆ¾{((t Colorize ğ•©) lib.color.RGB 0)âˆ¾" "}Â¨ğ•© â‹„ âŸ¨âŸ©}Ë˜ğ•©
  ğ•©
}

Solve â‡ {part ğ•Š lines :
  shape â† (â‰ â‹ˆ(â‰ âŠ‘))lines
  map â† (shapeâŠ¸â¥Š)âˆ˜(sea_levelâŠ¸+'a'âŠ¸(-Ëœ))âˆ˜âˆ¾lines
  startâ€¿end â† (mapâŠ¸(IndexOfËœ)sea_levelâŠ¸+âˆ˜-âŸœ'a')Â¨'S'â€¿'E'
  mapâŸ¨sea_level,sea_level+'z'-'a'âŸ©âŒ¾(startâ€¿endâŠ¸âŠ‘) â†©
  reachables â† {(â‰¢map)â¥Š(Â¯1+â¥Šmap)â‰¤â¥Šğ•©}Â¨Neighbors map
  MaskedNeighbors â† reachablesÃ—{(ğ•©âŠ¸MakeNeighbor)Â¨â†•4}

  n â† {1=part ? m â† 1Ë™âŒ¾(startâŠ¸âŠ‘) map ; {sea_level=ğ•© ? 1 ; ğ•©}Â¨Ë˜map}
  n {0 Dump (ChooseÂ¨Ë˜Â´âŸœ MaskedNeighbors)ğ•©}â€¢_while_{0>endâŠ‘ğ•©} â†©
  â€¢Delay 3
  â€¢Out lib.term.resetâˆ¾lib.term.clear
  Â¯1âŠ¸+endâŠ¸âŠ‘n
}
