lib ← •Import "../lib.bqn"

Solve ⇐ { part Solve data:
  Facets ← {x‿y‿z :
    [⟨x-0.5,y,z⟩,⟨x+0.5,y,z⟩,⟨x,y-0.5,z⟩,⟨x,y+0.5,z⟩,⟨x,y,z-0.5⟩,⟨x,y,z+0.5⟩]
  }
  "≠all" lib.Debug≠ all ← ⥊<˘∾Facets¨lib.ParseInts¨data
  { 1=part ? (≠-(2⊸×∘(-○≠⟜⍷)))all ;
    2=part ?
      # {
      #   "all facets" lib.Debug a ← ⟨⟨0,0⟩,⟨1,0⟩,⟨0,0⟩,⟨2,0⟩,⟨2,0⟩⟩
      #   "a's non-firsts mask" lib.Debug m ← ¬∊a
      #   "a's non-firsts" lib.Debug c ← m/a
      #   "remains" lib.Debug (¬a∊c)/a
      #   !0
      # }
      "5↑dup faces" lib.Debug 5↑dup ← (¬∊)⊸/all
      # Change to a directed space
      Lift ← {𝕊 x‿y‿z :
        {
          x≠⌊x ? ⟨x+0.5,y,z,3⟩‿⟨x-0.5,y,z,2⟩ ;
          y≠⌊y ? ⟨x,y+0.5,z,5⟩‿⟨x,y-0.5,z,4⟩ ;
          z≠⌊z ? ⟨x,y,z+0.5,7⟩‿⟨x,y,z-0.5,6⟩ ;
          !0
        }
      }
      DirectedFacets ← ∾¨⟜(2+↕6)<
      "5↑dir¯all" lib.Debug 5↑dir¯all ← ∾DirectedFacets¨ lib.ParseInts¨data
      "≠mask" lib.Debug +´mask ← dir¯all∊∾Lift¨ dup
      "≠surface" lib.Debug ≠surface ← (¬mask)/dir¯all
      Adjacent ← {a𝕊b:
        # {1‿¯1‿0≡b-○(3⊸↑)a ? lib.Debug a‿b; @}
        dirs ← a∾○(3⊸⊑)b
        {
          𝕊 ⟨ 0, 0, 0⟩ : ¬⊑(<∧dirs)∊⟨2‿3,4‿5,6‿7⟩;

          𝕊 ⟨ 0, 0, 1⟩ : (=´dirs)∧3≠⌊2÷⁼3⊑a;
          𝕊 ⟨ 0, 0,¯1⟩ : (=´dirs)∧3≠⌊2÷⁼3⊑a;
          𝕊 ⟨ 0, 1, 0⟩ : (=´dirs)∧2≠⌊2÷⁼3⊑a;
          𝕊 ⟨ 0,¯1, 0⟩ : (=´dirs)∧2≠⌊2÷⁼3⊑a;
          𝕊 ⟨ 1, 0, 0⟩ : (=´dirs)∧1≠⌊2÷⁼3⊑a;
          𝕊 ⟨¯1, 0, 0⟩ : (=´dirs)∧1≠⌊2÷⁼3⊑a;

          𝕊 ⟨ 0, 1, 1⟩ : ⊑(<dirs)∊⟨4‿7,6‿5⟩;
          𝕊 ⟨ 0, 1,¯1⟩ : ⊑(<dirs)∊⟨4‿6,7‿5⟩;
          𝕊 ⟨ 0,¯1, 1⟩ : ⊑(<dirs)∊⟨5‿7,6‿4⟩;
          𝕊 ⟨ 0,¯1,¯1⟩ : ⊑(<dirs)∊⟨5‿6,7‿4⟩;
          𝕊 ⟨ 1, 0, 1⟩ : ⊑(<dirs)∊⟨2‿7,6‿3⟩;
          𝕊 ⟨ 1, 0,¯1⟩ : ⊑(<dirs)∊⟨2‿6,7‿3⟩;
          𝕊 ⟨¯1, 0, 1⟩ : ⊑(<dirs)∊⟨3‿7,6‿2⟩;
          𝕊 ⟨¯1, 0,¯1⟩ : ⊑(<dirs)∊⟨3‿6,7‿2⟩;
          𝕊 ⟨ 1, 1, 0⟩ : ⊑(<dirs)∊⟨2‿5,4‿3⟩;
          𝕊 ⟨ 1,¯1, 0⟩ : ⊑(<dirs)∊⟨2‿4,5‿3⟩;
          𝕊 ⟨¯1, 1, 0⟩ : ⊑(<dirs)∊⟨3‿5,4‿2⟩;
          𝕊 ⟨¯1,¯1, 0⟩ : ⊑(<dirs)∊⟨3‿4,5‿2⟩;
          𝕊          𝕩: 0
        } b-○(3⊸↑)a
      }
      A ← {a𝕊b:
        # {1‿¯1‿0≡b-○(3⊸↑)a ? lib.Debug a‿b; @}
        dirs ← a∾○(3⊸⊑)b
        {
          𝕊 ⟨ 0, 0, 0⟩ : 1;

          𝕊 ⟨ 0, 0, 1⟩ : 1;
          𝕊 ⟨ 0, 0,¯1⟩ : 1;
          𝕊 ⟨ 0, 1, 0⟩ : 1;
          𝕊 ⟨ 0,¯1, 0⟩ : 1;
          𝕊 ⟨ 1, 0, 0⟩ : 1;
          𝕊 ⟨¯1, 0, 0⟩ : 1;

          𝕊 ⟨ 0, 1, 1⟩ : 1;
          𝕊 ⟨ 0, 1,¯1⟩ : 1;
          𝕊 ⟨ 0,¯1, 1⟩ : 1;
          𝕊 ⟨ 0,¯1,¯1⟩ : 1;
          𝕊 ⟨ 1, 0, 1⟩ : 1;
          𝕊 ⟨ 1, 0,¯1⟩ : 1;
          𝕊 ⟨¯1, 0, 1⟩ : 1;
          𝕊 ⟨¯1, 0,¯1⟩ : 1;
          𝕊 ⟨ 1, 1, 0⟩ : 1;
          𝕊 ⟨ 1,¯1, 0⟩ : 1;
          𝕊 ⟨¯1, 1, 0⟩ : 1;
          𝕊 ⟨¯1,¯1, 0⟩ : 1;
          𝕊          𝕩: 0
        } b-○(3⊸↑)a
      }
      !0‿0‿0‿2 Adjacent 1‿¯1‿0‿4
      !0‿0‿0‿5 Adjacent 1‿¯1‿0‿3
      "outers" lib.Debug 0{
        checked Rec remain‿⟨⟩  : checked;
        checked Rec remain‿new :
          # "matrix check" lib.Debug ⊑˘⊸/ ⊏˘>remain {⟨𝕨 A 𝕩, 𝕨 ⋈ 𝕩, 𝕨 Adjacent 𝕩⟩}⌜ new
          "matrix" lib.Debug ⌈´˘ remain Adjacent⌜ new
          "match" lib.Debug match ← {∨´new Adjacent¨<𝕩}¨remain
          "≠remain → ≠new" lib.Debug⟨≠remain,+´match⟩
          (checked+≠new) Rec match⊔remain ;
        checked Rec remain     : checked
      }1(↓⋈↑)∧surface
    ;
      ⟨1 Solve data, 2 Solve data⟩
  }
}
