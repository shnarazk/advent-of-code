lib â† â€¢Import "../lib.bqn"

Solve â‡ { part Solve data:
  Facets â† {xâ€¿yâ€¿z :
    [âŸ¨x-0.5,y,zâŸ©,âŸ¨x+0.5,y,zâŸ©,âŸ¨x,y-0.5,zâŸ©,âŸ¨x,y+0.5,zâŸ©,âŸ¨x,y,z-0.5âŸ©,âŸ¨x,y,z+0.5âŸ©]
  }
  "â‰ all" lib.Debugâ‰  all â† â¥Š<Ë˜âˆ¾FacetsÂ¨lib.ParseIntsÂ¨data
  { 1=part ? (â‰ -(2âŠ¸Ã—âˆ˜(-â—‹â‰ âŸœâ·)))all ;
    2=part ?
      # {
      #   "all facets" lib.Debug a â† âŸ¨âŸ¨0,0âŸ©,âŸ¨1,0âŸ©,âŸ¨0,0âŸ©,âŸ¨2,0âŸ©,âŸ¨2,0âŸ©âŸ©
      #   "a's non-firsts mask" lib.Debug m â† Â¬âˆŠa
      #   "a's non-firsts" lib.Debug c â† m/a
      #   "remains" lib.Debug (Â¬aâˆŠc)/a
      #   !0
      # }
      "5â†‘dup faces" lib.Debug 5â†‘dup â† (Â¬âˆŠ)âŠ¸/all
      # Change to a directed space
      Lift â† {ğ•Š xâ€¿yâ€¿z :
        {
          xâ‰ âŒŠx ? âŸ¨x+0.5,y,z,3âŸ©â€¿âŸ¨x-0.5,y,z,2âŸ© ;
          yâ‰ âŒŠy ? âŸ¨x,y+0.5,z,5âŸ©â€¿âŸ¨x,y-0.5,z,4âŸ© ;
          zâ‰ âŒŠz ? âŸ¨x,y,z+0.5,7âŸ©â€¿âŸ¨x,y,z-0.5,6âŸ© ;
          !0
        }
      }
      DirectedFacets â† âˆ¾Â¨âŸœ(2+â†•6)<
      "5â†‘dirÂ¯all" lib.Debug 5â†‘dirÂ¯all â† âˆ¾DirectedFacetsÂ¨ lib.ParseIntsÂ¨data
      "â‰ mask" lib.Debug +Â´mask â† dirÂ¯allâˆŠâˆ¾LiftÂ¨ dup
      "â‰ surface" lib.Debug â‰ surface â† (Â¬mask)/dirÂ¯all
      Adjacent â† {ağ•Šb:
        # {1â€¿Â¯1â€¿0â‰¡b-â—‹(3âŠ¸â†‘)a ? lib.Debug aâ€¿b; @}
        dirs â† aâˆ¾â—‹(3âŠ¸âŠ‘)b
        {
          ğ•Š âŸ¨ 0, 0, 0âŸ© : Â¬âŠ‘(<âˆ§dirs)âˆŠâŸ¨2â€¿3,4â€¿5,6â€¿7âŸ©;

          ğ•Š âŸ¨ 0, 0, 1âŸ© : (=Â´dirs)âˆ§3â‰ âŒŠ2Ã·â¼3âŠ‘a;
          ğ•Š âŸ¨ 0, 0,Â¯1âŸ© : (=Â´dirs)âˆ§3â‰ âŒŠ2Ã·â¼3âŠ‘a;
          ğ•Š âŸ¨ 0, 1, 0âŸ© : (=Â´dirs)âˆ§2â‰ âŒŠ2Ã·â¼3âŠ‘a;
          ğ•Š âŸ¨ 0,Â¯1, 0âŸ© : (=Â´dirs)âˆ§2â‰ âŒŠ2Ã·â¼3âŠ‘a;
          ğ•Š âŸ¨ 1, 0, 0âŸ© : (=Â´dirs)âˆ§1â‰ âŒŠ2Ã·â¼3âŠ‘a;
          ğ•Š âŸ¨Â¯1, 0, 0âŸ© : (=Â´dirs)âˆ§1â‰ âŒŠ2Ã·â¼3âŠ‘a;

          ğ•Š âŸ¨ 0, 1, 1âŸ© : âŠ‘(<dirs)âˆŠâŸ¨4â€¿7,6â€¿5âŸ©;
          ğ•Š âŸ¨ 0, 1,Â¯1âŸ© : âŠ‘(<dirs)âˆŠâŸ¨4â€¿6,7â€¿5âŸ©;
          ğ•Š âŸ¨ 0,Â¯1, 1âŸ© : âŠ‘(<dirs)âˆŠâŸ¨5â€¿7,6â€¿4âŸ©;
          ğ•Š âŸ¨ 0,Â¯1,Â¯1âŸ© : âŠ‘(<dirs)âˆŠâŸ¨5â€¿6,7â€¿4âŸ©;
          ğ•Š âŸ¨ 1, 0, 1âŸ© : âŠ‘(<dirs)âˆŠâŸ¨2â€¿7,6â€¿3âŸ©;
          ğ•Š âŸ¨ 1, 0,Â¯1âŸ© : âŠ‘(<dirs)âˆŠâŸ¨2â€¿6,7â€¿3âŸ©;
          ğ•Š âŸ¨Â¯1, 0, 1âŸ© : âŠ‘(<dirs)âˆŠâŸ¨3â€¿7,6â€¿2âŸ©;
          ğ•Š âŸ¨Â¯1, 0,Â¯1âŸ© : âŠ‘(<dirs)âˆŠâŸ¨3â€¿6,7â€¿2âŸ©;
          ğ•Š âŸ¨ 1, 1, 0âŸ© : âŠ‘(<dirs)âˆŠâŸ¨2â€¿5,4â€¿3âŸ©;
          ğ•Š âŸ¨ 1,Â¯1, 0âŸ© : âŠ‘(<dirs)âˆŠâŸ¨2â€¿4,5â€¿3âŸ©;
          ğ•Š âŸ¨Â¯1, 1, 0âŸ© : âŠ‘(<dirs)âˆŠâŸ¨3â€¿5,4â€¿2âŸ©;
          ğ•Š âŸ¨Â¯1,Â¯1, 0âŸ© : âŠ‘(<dirs)âˆŠâŸ¨3â€¿4,5â€¿2âŸ©;
          ğ•Š          ğ•©: 0
        } b-â—‹(3âŠ¸â†‘)a
      }
      A â† {ağ•Šb:
        # {1â€¿Â¯1â€¿0â‰¡b-â—‹(3âŠ¸â†‘)a ? lib.Debug aâ€¿b; @}
        dirs â† aâˆ¾â—‹(3âŠ¸âŠ‘)b
        {
          ğ•Š âŸ¨ 0, 0, 0âŸ© : 1;

          ğ•Š âŸ¨ 0, 0, 1âŸ© : 1;
          ğ•Š âŸ¨ 0, 0,Â¯1âŸ© : 1;
          ğ•Š âŸ¨ 0, 1, 0âŸ© : 1;
          ğ•Š âŸ¨ 0,Â¯1, 0âŸ© : 1;
          ğ•Š âŸ¨ 1, 0, 0âŸ© : 1;
          ğ•Š âŸ¨Â¯1, 0, 0âŸ© : 1;

          ğ•Š âŸ¨ 0, 1, 1âŸ© : 1;
          ğ•Š âŸ¨ 0, 1,Â¯1âŸ© : 1;
          ğ•Š âŸ¨ 0,Â¯1, 1âŸ© : 1;
          ğ•Š âŸ¨ 0,Â¯1,Â¯1âŸ© : 1;
          ğ•Š âŸ¨ 1, 0, 1âŸ© : 1;
          ğ•Š âŸ¨ 1, 0,Â¯1âŸ© : 1;
          ğ•Š âŸ¨Â¯1, 0, 1âŸ© : 1;
          ğ•Š âŸ¨Â¯1, 0,Â¯1âŸ© : 1;
          ğ•Š âŸ¨ 1, 1, 0âŸ© : 1;
          ğ•Š âŸ¨ 1,Â¯1, 0âŸ© : 1;
          ğ•Š âŸ¨Â¯1, 1, 0âŸ© : 1;
          ğ•Š âŸ¨Â¯1,Â¯1, 0âŸ© : 1;
          ğ•Š          ğ•©: 0
        } b-â—‹(3âŠ¸â†‘)a
      }
      !0â€¿0â€¿0â€¿2 Adjacent 1â€¿Â¯1â€¿0â€¿4
      !0â€¿0â€¿0â€¿5 Adjacent 1â€¿Â¯1â€¿0â€¿3
      "outers" lib.Debug 0{
        checked Rec remainâ€¿âŸ¨âŸ©  : checked;
        checked Rec remainâ€¿new :
          # "matrix check" lib.Debug âŠ‘Ë˜âŠ¸/ âŠË˜>remain {âŸ¨ğ•¨ A ğ•©, ğ•¨ â‹ˆ ğ•©, ğ•¨ Adjacent ğ•©âŸ©}âŒœ new
          "matrix" lib.Debug âŒˆÂ´Ë˜ remain AdjacentâŒœ new
          "match" lib.Debug match â† {âˆ¨Â´new AdjacentÂ¨<ğ•©}Â¨remain
          "â‰ remain â†’ â‰ new" lib.DebugâŸ¨â‰ remain,+Â´matchâŸ©
          (checked+â‰ new) Rec matchâŠ”remain ;
        checked Rec remain     : checked
      }1(â†“â‹ˆâ†‘)âˆ§surface
    ;
      âŸ¨1 Solve data, 2 Solve dataâŸ©
  }
}
