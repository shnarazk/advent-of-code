lib ‚Üê ‚Ä¢Import "../lib.bqn"

Solve ‚áê { part Solve data:
  { 1=part ?
      Facets ‚Üê {x‚Äøy‚Äøz:
        [
          ‚ü®x-0.5,y,z‚ü©,‚ü®x+0.5,y,z‚ü©
          ‚ü®x,y-0.5,z‚ü©,‚ü®x,y+0.5,z‚ü©
          ‚ü®x,y,z-0.5‚ü©,‚ü®x,y,z+0.5‚ü©
        ]
      }
      "fs" lib.Debug ‚â†fs ‚Üê ‚•ä<Àò‚àæFacets¬® cubes ‚Üê lib.ParseInts¬®data
      # (1‚ä∏=¬∑+¬¥Àò(‚àß¬¥=)‚åúÀú)‚ä∏/ fs out of memory
      (‚â†-(2‚ä∏√ó‚àò(-‚óã‚â†‚üú‚ç∑)))fs
      # if you need not only the number of facets but also facets themselves.
      # "lib.Debug ‚â†envelop ‚Üê {1=+¬¥‚àß¬¥¬®fs=<ùï©}¬®‚ä∏/ fs
      ;
    2=part ?
      # we need 'direction'
      Facets ‚Üê ‚àæ¬®‚üú(1+‚Üï6)<
      # lib.Debug Facets 0‚Äø0‚Äø0
      "5‚Üëall" lib.Debug 5‚Üëall ‚Üê ‚àæFacets¬® lib.ParseInts¬®data
      Mirrored ‚Üê {aùïäb:
        {
          ‚ü® 0, 0, 1‚ü©: 1‚Äø2‚â°a‚àæ‚óã(3‚ä∏‚äë)b;
          ‚ü® 0, 0,¬Ø1‚ü©: 2‚Äø1‚â°a‚àæ‚óã(3‚ä∏‚äë)b;
          ‚ü® 0, 1, 0‚ü©: 3‚Äø4‚â°a‚àæ‚óã(3‚ä∏‚äë)b;
          ‚ü® 0,¬Ø1, 0‚ü©: 4‚Äø3‚â°a‚àæ‚óã(3‚ä∏‚äë)b;
          ‚ü® 1, 0, 0‚ü©: 5‚Äø6‚â°a‚àæ‚óã(3‚ä∏‚äë)b;
          ‚ü®¬Ø1, 0, 0‚ü©: 6‚Äø5‚â°a‚àæ‚óã(3‚ä∏‚äë)b;
                ùï©: 0
        } b-‚óã(3‚ä∏‚Üë)a
      }
      # {‚à®¬¥checked Mirrored¬® <cand ? checked; checked ‚àæ cand}
      ! ‚ü®0,0,0,1‚ü©Mirrored‚ü®0,0,1,2‚ü©
      "matrix1" lib.Debug √óÀú‚â†all
      # "matrix" +Àù Mirrored‚åúÀúall  ## out of memory
      "facets" lib.Debug ‚â†fs ‚Üê ‚ü®‚ü©{candùïächecked:
        matches ‚Üê checked Mirrored¬®<cand
        {‚à®¬¥matches ? (¬¨matches)/checked ; checked‚àæ<cand}
      }¬¥all
        # (<cand)‚àæ‚çü(¬¨‚à®¬¥checked Mirrored¬®<cand)checked}¬¥all
      "5‚Üëfs" lib.Debug 5‚Üëfs
      Adjacent ‚Üê {aùïäb:
        { 1‚Äø¬Ø1‚Äø0‚â°b-‚óã(3‚ä∏‚Üë)a ? lib.Debug a‚Äøb; @}
        {
          ùïä ‚ü® 0, 0, 1‚ü©: (a=‚óã(3‚ä∏‚äë)b)‚àß1‚â†‚åä2√∑‚Åº3‚äëa;
          ùïä ‚ü® 0, 0,¬Ø1‚ü©: (a=‚óã(3‚ä∏‚äë)b)‚àß1‚â†‚åä2√∑‚Åº3‚äëa;
          ùïä ‚ü® 0, 1, 0‚ü©: (a=‚óã(3‚ä∏‚äë)b)‚àß2‚â†‚åä2√∑‚Åº3‚äëa;
          ùïä ‚ü® 0,¬Ø1, 0‚ü©: (a=‚óã(3‚ä∏‚äë)b)‚àß2‚â†‚åä2√∑‚Åº3‚äëa;
          ùïä ‚ü® 1, 0, 0‚ü©: (a=‚óã(3‚ä∏‚äë)b)‚àß3‚â†‚åä2√∑‚Åº3‚äëa;
          ùïä ‚ü®¬Ø1, 0, 0‚ü©: (a=‚óã(3‚ä∏‚äë)b)‚àß3‚â†‚åä2√∑‚Åº3‚äëa;

          ùïä ‚ü® 0, 1, 1‚ü©: 3‚Äø2‚â°a‚àæ‚óã(3‚ä∏‚äë)b;
          ùïä ‚ü® 0, 1,¬Ø1‚ü©: 4‚Äø2‚â°a‚àæ‚óã(3‚ä∏‚äë)b;
          ùïä ‚ü® 0,¬Ø1, 1‚ü©: 3‚Äø1‚â°a‚àæ‚óã(3‚ä∏‚äë)b;
          ùïä ‚ü® 0,¬Ø1,¬Ø1‚ü©: 4‚Äø1‚â°a‚àæ‚óã(3‚ä∏‚äë)b;

          ùïä ‚ü® 1, 0, 1‚ü©: 5‚Äø2‚â°a‚àæ‚óã(3‚ä∏‚äë)b;
          ùïä ‚ü® 1, 0,¬Ø1‚ü©: 5‚Äø1‚â°a‚àæ‚óã(3‚ä∏‚äë)b;
          ùïä ‚ü®¬Ø1, 0, 1‚ü©: 5‚Äø1‚â°a‚àæ‚óã(3‚ä∏‚äë)b;
          ùïä ‚ü®¬Ø1, 0,¬Ø1‚ü©: 6‚Äø1‚â°a‚àæ‚óã(3‚ä∏‚äë)b;

          ùïä ‚ü® 1, 1, 0‚ü©: 5‚Äø4‚â°a‚àæ‚óã(3‚ä∏‚äë)b;
          ùïä ‚ü® 1,¬Ø1, 0‚ü©: 5‚Äø3‚â°a‚àæ‚óã(3‚ä∏‚äë)b; # !!
          ùïä ‚ü®¬Ø1, 1, 0‚ü©: 6‚Äø4‚â°a‚àæ‚óã(3‚ä∏‚äë)b;
          ùïä ‚ü®¬Ø1,¬Ø1, 0‚ü©: 6‚Äø3‚â°a‚àæ‚óã(3‚ä∏‚äë)b;
          ùïä          ùï©: 0
        } b-‚óã(3‚ä∏‚Üë)a
      }
      ! 0‚Äø0‚Äø0‚Äø5 Adjacent 1‚Äø¬Ø1‚Äø0‚Äø3
      "outers" lib.Debug ‚â†out ‚Üê ‚ü®‚ü© {
        checked Rec ‚ü®‚ü©‚Äøremain: checked;
        checked Rec new‚Äøremain:
          "‚â†remain" lib.Debug ‚â†remain
          match ‚Üê {‚à®¬¥new Adjacent¬®<ùï©}¬®remain
          "new" lib.Debug match
          (checked‚àænew) Rec match ‚äî remain;
        checked Rec new: checked‚àænew
      } 1(‚Üë‚ãà‚Üì)fs
    ;
      ‚ü®1 Solve data, 2 Solve data‚ü©
  }
}
