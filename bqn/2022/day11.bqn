Solve â‡ {envâ€¿part ğ•Š lines :
  lib â† â€¢Import"/util.bqn"âˆ¾Ëœâˆ¾env.Var<"BQN_LIB"
  Convert â† {ğ•Š noâ€¿itemsâ€¿updateâ€¿testâ€¿thenâ€¿elseâ€¿end :
    u â† 19â†“update
    <âŸ¨
      lib.ParseInt no
      0(+âŸœ(2âŠ¸Ã—))Â´("+*" âˆŠ u), # op-code encoded to 1 or 2
      {2=+Â´("old"âŠ¸(lib.StartsWithËœ))Â¨â†“u ? Â¯1 ; lib.ParseInt u} # oprand
      lib.ParseInt test
      lib.ParseInt then
      lib.ParseInt else
    âŸ©
  }
  {k â† 7-7|â‰ lines â‹„  0<k ? lines â†© linesâˆ¾âŸ¨âŸ©Ë™Â¨â†•k ; @}
  lines â†© âˆ˜â€¿7â¥Šlines
  status â† (<Â·lib.ParseInts 1âŠ¸âŠ‘)Ë˜lines
  inspects â† 0Ë™Â¨â†•â‰  monkeys â† â¥ŠConvertË˜lines
  limit â† â€¢math.lcmÂ´(3âŠ¸âŠ‘)Â¨monkeys
  Updater â† {noâ€¿opâ€¿argâ€¿testâ€¿thenâ€¿else ğ•Š statusâ€¿ins :
    âŸ¨s,nâŸ© â† âŸ¨status,â‰ noâŠ‘statusâŸ©
    {ğ•Š item :
      item â†© (Â¯1+part)Ë™â—¶âŸ¨âŒŠ3âŠ¸(Ã·Ëœ),limitâŠ¸|âŸ©op{
        1 ğ•Š Â¯1 : itemÃ—2 ;
        1 ğ•Š ğ•©  : item+ğ•© ;
        2 ğ•Š Â¯1 : itemâ‹†2 ;
        2 ğ•Š ğ•©  : itemÃ—ğ•©
      }arg
      s â†© (âˆ¾âŸœâŸ¨itemâŸ©)âŒ¾(((0=test|item)âŠ‘âŸ¨else,thenâŸ©)âŠ¸âŠ‘)s
    }Â¨noâŠ‘status
    âŸ¨âŸ¨âŸ©Ë™âŒ¾(noâŠ¸âŠ‘)s,(nâŠ¸+)âŒ¾(noâŠ¸âŠ‘)insâŸ©
  }
  Ã—Â´2â†‘âˆ¨1âŠ‘{ğ•©UpdaterÂ´âŒ½monkeys}âŸ{1=part ? 20 ; 10000}âŸ¨status,inspectsâŸ©
}
